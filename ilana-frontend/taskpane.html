<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ilana</title>
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js"></script>
    
    <script>
        // API Base URL Configuration
        // Production: Uses Render backend (https://ilanalabs-add-in.onrender.com)
        // Development: Set window.__DEV_MODE__ = true before this script loads to use localhost
        window.__ILANA_API_BASE__ = window.__DEV_MODE__
            ? "http://127.0.0.1:8000"
            : "https://ilanalabs-add-in.onrender.com";
    </script>
    <style>
        /* Professional taskpane design system */
        
        :root {
            --primary-green: #11a683;
            --primary-green-hover: #15c894;
            --primary-red: #ea1537;
            --primary-red-hover: #f23452;
            --primary-blue: #3b82f6;
            --primary-orange: #f59e0b;
            --text-gray: #8189a9;
            --text-dark: #0e101a;
            --background-light: #f0f2fc;
            --border-light: #e4e6f2;
            --surface-white: #ffffff;
            --surface-hover: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--surface-white);
            color: var(--text-dark);
            font-size: 14px;
            line-height: 1.4;
            height: 100vh;
            overflow: hidden;
        }

        /* Main sidebar wrapper */
        .sidebar-wrapper {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .wrapper {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Header wrapper */
        .header-wrapper {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the button */
            margin-bottom: 8px;
        }

        .lens-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-dark);
            display: none; /* Hide this element */
        }

        .header-btn {
            background: #0700ff;
            color: var(--surface-white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            position: relative;
            z-index: 10; /* above normal content, below modal */
        }

        .header-btn:hover {
            background: #0500cc;
        }

        .header-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Legacy pipeline label */
        .legacy-mode-label {
            background: var(--surface-gray);
            color: var(--text-dark);
            border: 1px solid #ddd;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        /* Navigation container */
        .navigation-container {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
            background: var(--background-light);
        }

        .all-alerts-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .all-alerts-stats {
            color: var(--text-gray);
            font-size: 13px;
        }

        .counter-wrapper {
            display: flex;
            gap: 16px;
        }

        .counter-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .counter-number {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            min-width: 18px;
            text-align: center;
        }

        .counter-number.low {
            background: var(--text-gray);
        }

        .counter-number.medium {
            background: var(--primary-orange);
        }

        /* Scroll content */
        .scroll-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .card-wrapper {
            border-bottom: 1px solid var(--border-light);
        }

        .card-wrapper:last-child {
            border-bottom: none;
        }

        /* Full card structure */
        .full-card {
            padding: 20px;
            background: #fff;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(10, 20, 40, 0.08);
            transition: box-shadow 0.18s ease, transform 0.08s ease, background 0.2s ease;
        }

        .full-card.minimized:hover, .full-card.maximized:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(10, 20, 40, 0.12);
        }

        .full-card:hover {
            background: var(--surface-hover);
        }

        .full-card.maximized {
            background: var(--background-light);
        }

        .full-card.accepted {
            border: 1px solid #2ecc71;
            box-shadow: 0 10px 30px rgba(46, 204, 113, 0.08);
        }

        .card-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--surface-white);
        }

        .card-logo.critical {
            background: var(--primary-red);
        }

        .card-logo.high {
            background: var(--primary-red);
        }

        .card-logo.medium {
            background: var(--primary-orange);
        }

        .card-logo.low {
            background: var(--text-gray);
        }

        /* Report list - suggestion items */
        .report-list {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .item-original {
            position: relative;
            color: var(--primary-red);
            text-decoration: line-through;
            margin-right: 8px;
            font-weight: 500;
        }

        .item-original:after {
            content: '‚Üí';
            color: var(--text-gray);
            margin-left: 8px;
            text-decoration: none;
        }

        .item-insert {
            background: var(--primary-green);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-insert:hover {
            background: var(--primary-green-hover);
        }

        .item-remove {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-remove:hover {
            background: var(--primary-red-hover);
        }

        /* Full sentence background */
        .full-sentence-background {
            background: var(--background-light);
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
            font-style: italic;
            line-height: 1.4;
            color: var(--text-dark);
            max-height: 200px;
            overflow-y: auto;
        }

        .full-sentence-insert {
            color: var(--primary-green);
            font-weight: 600;
        }

        .full-sentence-delete {
            color: var(--primary-red);
            text-decoration: line-through;
            font-weight: 600;
        }

        /* Card footer */
        .card-footer {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .card-footer-btn {
            background: transparent;
            border: 1px solid var(--border-light);
            color: var(--text-dark);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-footer-btn:hover {
            background: var(--surface-hover);
            border-color: var(--text-gray);
        }

        .card-footer-btn.primary {
            background: #0700ff;
            border-color: #0700ff;
            color: var(--surface-white);
        }

        .card-footer-btn.primary:hover {
            background: #0500cc;
            border-color: #0500cc;
        }

        .card-footer-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .card-footer-btn .btn-spinner {
            margin-left: 4px;
        }

        .card-footer-btn.accepted-badge {
            background: transparent;
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.12);
            cursor: default;
        }

        /* Accepted state */
        .issue-card.accepted {
            border-left: 4px solid var(--primary-green);
            background: linear-gradient(to right, rgba(76, 175, 80, 0.05) 0%, transparent 100%);
        }

        .accepted-badge {
            display: inline-block;
            background: var(--primary-green);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .accepted-timestamp {
            font-size: 11px;
            color: var(--text-gray);
            margin-left: 4px;
        }

        /* Alignment badges */
        .alignment-badges {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .alignment-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            border: 1px solid;
            cursor: help;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            position: relative;
        }

        .alignment-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .alignment-badge.good {
            background: rgba(46, 204, 113, 0.1);
            color: #2ecc71;
            border-color: rgba(46, 204, 113, 0.3);
        }

        .alignment-badge.warning {
            background: rgba(243, 156, 18, 0.1);
            color: #f39c12;
            border-color: rgba(243, 156, 18, 0.3);
        }

        .alignment-badge.danger {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.3);
        }

        .badge-icon {
            font-size: 11px;
            font-weight: bold;
        }

        .badge-label {
            font-size: 10px;
            text-transform: capitalize;
        }

        /* Tooltip for alignment badges */
        .alignment-badge[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 6px;
            padding: 6px 10px;
            background: #323232;
            color: white;
            font-size: 11px;
            font-weight: normal;
            border-radius: 4px;
            white-space: nowrap;
            max-width: 250px;
            white-space: normal;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }

        .alignment-badge[title]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 0px;
            border: 4px solid transparent;
            border-top-color: #323232;
            z-index: 1001;
            pointer-events: none;
        }

        /* Clinical Impact expand/collapse */
        .clinical-impact-container {
            margin-top: 12px;
        }

        .clinical-impact-text {
            line-height: 1.5;
            color: var(--text-dark);
        }

        .clinical-impact-text.truncated {
            /* Removed line-clamp to allow full text display */
            /* Text expand/collapse is handled by Read more/Show less button */
            /* display: -webkit-box; */
            /* -webkit-line-clamp: 3; */
            /* -webkit-box-orient: vertical; */
            /* overflow: hidden; */
        }

        .clinical-impact-loading {
            opacity: 0.6;
            font-style: italic;
        }

        .read-more-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: transparent;
            border: none;
            color: var(--primary-blue);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            padding: 4px 0;
            margin-top: 4px;
            text-decoration: underline;
            transition: color 0.2s ease;
        }

        .read-more-btn:hover {
            color: var(--primary-green);
        }

        .read-more-btn:focus {
            outline: 2px solid var(--primary-blue);
            outline-offset: 2px;
            border-radius: 2px;
        }

        .clinical-impact-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--border-light);
            border-top-color: var(--primary-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Undo toast */
        .undo-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 16px;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                bottom: -100px;
                opacity: 0;
            }
            to {
                bottom: 20px;
                opacity: 1;
            }
        }

        .undo-toast.hiding {
            animation: slideDown 0.3s ease forwards;
        }

        @keyframes slideDown {
            from {
                bottom: 20px;
                opacity: 1;
            }
            to {
                bottom: -100px;
                opacity: 0;
            }
        }

        .undo-toast-text {
            font-size: 13px;
        }

        .undo-toast-btn {
            background: var(--primary-green);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .undo-toast-btn:hover {
            background: var(--primary-green-hover);
        }

        /* Minimized state */
        .minimized .report-list {
            margin-bottom: 0;
        }

        .minimized .full-sentence-background,
        .minimized .card-footer {
            display: none;
        }

        /* Status indicators */
        .status-indicator {
            padding: 12px 20px;
            text-align: center;
            font-size: 13px;
            background: var(--background-light);
            color: var(--text-gray);
            border-bottom: 1px solid var(--border-light);
            display: none; /* Hide status indicator */
        }

        .status-indicator.analyzing {
            color: var(--primary-blue);
        }

        .status-indicator.complete {
            background: var(--primary-green);
            color: var(--surface-white);
        }

        .status-indicator.error {
            background: var(--primary-red);
            color: var(--surface-white);
        }

        /* Loading animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* Fix modal backdrop click interception bug */
        .analysis-modal.hidden {
            pointer-events: none;
        }

        .analysis-modal.hidden .modal-backdrop {
            pointer-events: none;
        }

        /* Spinner animation */
        .spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal body scroll lock */
        body.modal-open {
            overflow: hidden;
        }

        /* Analysis Modal Styles */
        .analysis-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Modal backdrop - hidden by default, explicit state control */
        .modal-backdrop {
            position: fixed;
            inset: 0; /* top:0; right:0; bottom:0; left:0 */
            background: rgba(0, 0, 0, 0.35);
            display: none;            /* hidden by default */
            pointer-events: none;     /* don't intercept clicks when hidden */
            z-index: 999;             /* below modal container */
        }

        /* When modal is open, show backdrop and allow clicks (to close) */
        .modal-backdrop.open {
            display: block;
            pointer-events: auto;
        }

        .modal-container {
            background: white;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000; /* higher than backdrop */
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px 0;
            border-bottom: 1px solid var(--border-light);
            margin-bottom: 20px;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--text-dark);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-gray);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background-color: var(--surface-hover);
        }

        .modal-body {
            padding: 0 24px 24px;
        }

        .modal-description {
            margin: 0 0 20px 0;
            color: var(--text-gray);
            font-size: 14px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .modal-option {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .modal-option:hover,
        .modal-option:focus {
            border-color: var(--primary-green);
            background: var(--surface-hover);
            outline: none;
        }

        /* Hide document analysis options (selection-only mode) */
        .modal-option.truncated,
        .modal-option.queue {
            display: none !important;
        }

        .option-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .option-content h3 {
            margin: 0 0 4px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
        }

        .option-content p {
            margin: 0;
            font-size: 12px;
            color: var(--text-gray);
            line-height: 1.4;
        }

        .modal-warning {
            padding: 12px;
            background: var(--background-light);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-gray);
            border-left: 3px solid var(--primary-orange);
        }

        /* Job Queued Styles */
        .job-queued-container {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 24px;
            background: var(--background-light);
            border: 2px solid var(--primary-blue);
            border-radius: 8px;
            margin: 20px;
        }

        .job-queued-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .job-queued-content h3 {
            margin: 0 0 8px 0;
            color: var(--primary-blue);
            font-size: 16px;
            font-weight: 600;
        }

        .job-queued-content p {
            margin: 4px 0;
            font-size: 12px;
            color: var(--text-gray);
        }

        .job-queued-content code {
            background: var(--surface-white);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
        }

        .job-queued-description {
            margin: 12px 0;
            padding: 12px;
            background: var(--surface-white);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
            color: var(--text-dark);
        }

        .job-queued-actions {
            margin-top: 12px;
        }

        .check-status-btn {
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .check-status-btn:hover {
            background: var(--primary-blue);
            filter: brightness(1.1);
        }

        /* Empty state */
        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-gray);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: var(--primary-green);
        }

        .empty-state-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-dark);
        }

        .empty-state-subtitle {
            font-size: 13px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- Professional sidebar wrapper -->
    <div class="sidebar-wrapper">
        <div class="wrapper">
            <!-- Header wrapper -->
            <div class="header-wrapper">
                <div class="header">
                    <div class="lens-title">Ilana</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <!-- Legacy pipeline label -->
                        <div class="legacy-mode-label" title="Production RAG pipeline with Pinecone vector search (53,848 exemplars) and PubMedBERT medical embeddings">
                            <span>Legacy (RAG + PubMedBERT)</span>
                        </div>

                        <button id="analyzeButton" class="header-btn" onclick="analyzeProtocol()">
                            <span id="analyzeButtonText">Analyze</span>
                            <span id="analyzeSpinner" class="spinner hidden">‚è≥</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Status indicator -->
            <div id="statusIndicator" class="status-indicator hidden">
                <span id="statusText"></span>
            </div>

            <!-- Navigation container -->
            <div id="navigationContainer" class="navigation-container hidden">
                <div class="all-alerts-container">
                    <div class="all-alerts-stats">
                        <span id="totalIssues">0 issues found</span>
                    </div>
                    <div class="counter-wrapper">
                        <div class="counter-content">
                            <span class="counter-number" id="criticalCount">0</span>
                            <span>Critical</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number medium" id="mediumCount">0</span>
                            <span>Medium</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number low" id="lowCount">0</span>
                            <span>Low</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scroll content -->
            <div class="scroll-content">
                <div id="cardsList"></div>
                
                <!-- Empty state -->
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">‚úì</div>
                    <div class="empty-state-title">Ready to analyze</div>
                    <div class="empty-state-subtitle">Select text and click "Analyze" to get targeted suggestions and check for clarity and compliance issues</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Options Modal -->
    <!-- Note: .modal-backdrop is created dynamically by ensureBackdrop() -->
    <script>
        // Pharmaceutical Protocol Analyzer - Professional Interface
        const API_BASE_URL = window.__ILANA_API_BASE__ || 'https://ilanalabs-add-in.onrender.com';
        console.log("API_BASE:", window.__ILANA_API_BASE__ || API_BASE_URL);
        const MAX_DOC_CHARS = 20000; // Default truncation limit
        let currentIssues = [];
        let maximizedCard = null;

        // ===== SAFE DOM HELPER =====
        // Safely query DOM elements and warn if not found
        function getEl(selector) {
            const el = document.querySelector(selector);
            if (!el) {
                console.warn(`getEl: selector "${selector}" not found in DOM`);
                return null;
            }
            return el;
        }

        // Safe helper for getElementById
        function getById(id) {
            const el = document.getElementById(id);
            if (!el) {
                console.warn(`getById: element with id "${id}" not found in DOM`);
                return null;
            }
            return el;
        }

        // Track Clinical Impact expand/collapse state
        const clinicalImpactExpanded = new Map(); // suggestionId -> boolean
        const clinicalImpactLoading = new Set(); // Set of suggestionIds currently loading
        const clinicalImpactFullText = new Map(); // suggestionId -> full text string

        // Global state for current therapeutic area
        window.IlanaState = {
            currentTA: 'general_medicine',
        };

        // Debounce tracking for highlight clicks
        const highlightDebounce = {
            lastIssueId: null,
            lastClickTime: 0,
            debounceMs: 500
        };

        // Global spinner tracking
        const activeSpinners = new Set();

        // Global spinner helpers
        function showSpinner(id) {
            activeSpinners.add(id);
            console.log(`üîÑ Spinner started: ${id}`);
            
            // Update UI based on spinner type
            if (id === 'analyze') {
                setAnalyzeButtonState(true, 'Analyzing...');
            } else if (id === 'ta_enhancement') {
                const button = document.querySelector(`[data-spinner-id="${id}"]`);
                if (button) {
                    button.disabled = true;
                    button.innerHTML = '‚è≥ Loading...';
                }
            }
        }

        function hideSpinner(id) {
            activeSpinners.delete(id);
            console.log(`‚úÖ Spinner stopped: ${id}`);
            
            // Update UI based on spinner type
            if (id === 'analyze') {
                setAnalyzeButtonState(false, 'Analyze');
            } else if (id === 'ta_enhancement') {
                const button = document.querySelector(`[data-spinner-id="${id}"]`);
                if (button) {
                    button.disabled = false;
                    button.innerHTML = 'TA-Enhanced';
                }
            }
        }

        // Global fetch wrapper with timeout and error handling
        async function fetchWithTimeout(url, options = {}, timeoutMs = 25000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    return {
                        ok: false,
                        reason: 'http_error',
                        status: response.status,
                        statusText: response.statusText,
                        error_code: errorData.error_code,
                        message: errorData.message || `HTTP ${response.status}: ${response.statusText}`,
                        request_id: errorData.request_id
                    };
                }
                
                return {
                    ok: true,
                    response: response,
                    json: async () => await response.json()
                };
                
            } catch (error) {
                clearTimeout(timeoutId);
                
                if (error.name === 'AbortError') {
                    return {
                        ok: false,
                        reason: 'timeout',
                        message: `Request timed out after ${timeoutMs}ms. Please try selecting smaller text or check your connection.`,
                        timeoutMs: timeoutMs
                    };
                }
                
                return {
                    ok: false,
                    reason: 'network_error',
                    message: error.message || 'Network error occurred',
                    error: error
                };
            }
        }

        // --- debug helper: defensive fix for stuck modal/backdrop ---
        // Place this near modal helper functions (openAnalysisModal/closeAnalysisModal)
        (function() {
            const isDebugAllowed = () => {
                try {
                    if (window.__ILANA_DEBUG__ === true) return true;
                    const host = window.location.hostname || "";
                    if (host.includes("localhost") || host.includes("127.0.0.1") || host.includes("ngrok")) return true;
                    if (window.location.search && window.location.search.includes("ilana_debug=1")) return true;
                } catch (e) {}
                return false;
            };

            async function debugFixBackdrop() {
                const result = { removed: 0, ensuredBackdrop: false, analyzeEnabled: false, reWired: false, errors: [] };

                try {
                    // 1) Remove orphan/backdrop duplicates
                    const bds = Array.from(document.querySelectorAll('.modal-backdrop'));
                    bds.forEach((el, idx) => {
                        try {
                            // hide then remove to avoid immediate layout thrash
                            el.style.display = 'none';
                            el.classList.remove('open');
                            el.remove();
                            result.removed += 1;
                        } catch (e) {
                            result.errors.push(`remove-backdrop-${idx}:${e.message}`);
                        }
                    });

                    // 2) Ensure single backdrop exists and is wired
                    // Use ensureBackdrop() if available, otherwise create manually
                    try {
                        if (typeof ensureBackdrop === 'function') {
                            ensureBackdrop();
                            result.ensuredBackdrop = true;
                        } else {
                            // Fallback: manual backdrop creation
                            let bd = document.querySelector('.modal-backdrop');
                            if (!bd) {
                                bd = document.createElement('div');
                                bd.className = 'modal-backdrop';
                                bd.setAttribute('role', 'presentation');
                                document.body.appendChild(bd);
                            }
                            // Strip all event listeners by cloning
                            const newBd = bd.cloneNode(false);
                            bd.replaceWith(newBd);
                            // Add canonical click listener
                            newBd.addEventListener('click', () => {
                                try { if (typeof closeAnalysisModal === 'function') closeAnalysisModal(); } catch(e){ console.warn(e); }
                            });
                            result.ensuredBackdrop = true;
                        }
                    } catch (e) {
                        result.errors.push('ensureBackdrop:' + e.message);
                    }

                    // 3) Restore modal container state if present
                    const container = document.querySelector('.modal-container');
                    if (container) {
                        // Ensure it's hidden by default unless explicitly open
                        if (!container.classList.contains('open')) {
                            container.style.display = 'none';
                            container.setAttribute('aria-hidden', 'true');
                        }
                    }

                    // 4) Re-enable Analyze button
                    const analyzeBtn = document.getElementById('analyzeButton');
                    if (analyzeBtn) {
                        analyzeBtn.disabled = false;
                        analyzeBtn.removeAttribute('aria-busy');
                        analyzeBtn.focus?.();
                        result.analyzeEnabled = true;
                    }

                    // 5) Re-wire modal option handlers
                    // Use wireModalOptionHandlers() if available, otherwise manual re-wire
                    try {
                        if (typeof wireModalOptionHandlers === 'function') {
                            wireModalOptionHandlers();
                            result.reWired = true;
                        } else {
                            // Fallback: manual re-wiring
                            const selectBtn = document.querySelector('.modal-option.select-text');
                            if (selectBtn && typeof selectTextOption === 'function') {
                                selectBtn.removeEventListener('click', selectTextOption);
                                selectBtn.addEventListener('click', selectTextOption);
                            }
                            // Document analysis event listeners removed - selection-only mode
                            const closeBtn = document.querySelector('.modal-close');
                            if (closeBtn && typeof closeAnalysisModal === 'function') {
                                closeBtn.removeEventListener('click', closeAnalysisModal);
                                closeBtn.addEventListener('click', closeAnalysisModal);
                            }
                            result.reWired = true;
                        }
                    } catch (e) {
                        result.errors.push('rewire:' + e.message);
                    }

                    // 6) cleanup any stray aria-hidden on body
                    try {
                        document.body.classList.remove('modal-open');
                    } catch(e) {}

                } catch (err) {
                    result.errors.push('fatal:' + (err && err.message));
                }

                console.info('debugFixBackdrop:', result);
                return result;
            }

            if (isDebugAllowed()) {
                window.debugFixBackdrop = debugFixBackdrop;
                console.info('Ilana debug helper: window.debugFixBackdrop() is available (debug mode)');
            }
        })();

        /*
         * DEBUG HELPER TEST INSTRUCTIONS:
         *
         * This function repairs the modal system when buttons become unresponsive.
         * It only works when debug mode is enabled.
         *
         * HOW TO USE:
         *
         * 1. Enable debug mode (choose ONE method):
         *    a) Add ?ilana_debug=1 to URL and reload, OR
         *    b) Run in console: window.__ILANA_DEBUG__ = true; (then reload), OR
         *    c) Use localhost/ngrok/127.0.0.1 (automatically enabled)
         *
         * 2. Open browser console (F12 ‚Üí Console tab)
         *
         * 3. Verify function is available:
         *    typeof window.debugFixBackdrop
         *    // Should output: "function"
         *
         * 4. Run the repair function (async):
         *    await window.debugFixBackdrop()
         *    // Should output: {removed: N, ensuredBackdrop: true, analyzeEnabled: true, reWired: true, errors: []}
         *
         * 5. Test functionality:
         *    - Click mode pill dropdown (should open)
         *    - Click analyze button (should work)
         *    - Open modal (should show with working buttons)
         *
         * EXPECTED OUTPUT:
         * {
         *   removed: 0-N,              // Number of orphaned backdrops removed
         *   ensuredBackdrop: true,     // Fresh backdrop created with click listener
         *   analyzeEnabled: true,      // Analyze button re-enabled and focused
         *   reWired: true,             // Modal button handlers re-attached
         *   errors: []                 // Empty if no errors, or array of error messages
         * }
         */

        /* --- Legacy Pipeline - No Mode Selection Required --- */

        // Initialize Ilana UI (non-Office-API dependent initialization)
        function initIlanaUI() {
            console.log('üé® Initializing Ilana UI...');

            try {
                // Initialize modal system
                console.log('üìã Initializing modal system...');
                ensureBackdrop();
                wireModalOptionHandlers();

                // Initialize accept change handlers
                console.log('‚úÖ Initializing accept change handlers...');
                initializeAcceptChangeHandlers();

                // Update status and keyboard handlers
                updateStatus('Ready to analyze pharmaceutical protocols', 'complete');
                setupKeyboardHandlers();

                console.log('‚úÖ Ilana UI initialization complete');
            } catch (error) {
                console.error('‚ùå Error during UI initialization:', error);
            }
        }

        // Initialize Office.js with proper error handling
        if (window.Office && typeof Office.onReady === 'function') {
            Office.onReady().then(() => {
                console.log('üöÄ Office ready ‚Äî initializing Ilana UI');
                console.log('üí° Debug help: Run window.debugFixBackdrop() if Analyze button is unresponsive');

                // Initialize user hash for telemetry (async, non-blocking, Office-API dependent)
                (async () => {
                    try {
                        console.log('üë§ Initializing user identity...');
                        const userEmail = Office.context.mailbox?.userProfile?.emailAddress ||
                                          Office.context.mailbox?.userProfile?.displayName ||
                                          'anonymous';
                        window.IlanaState.userHash = await hashString(userEmail);
                        console.log('‚úÖ User hash initialized');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Could not get user identity, using anonymous:', error);
                        window.IlanaState.userHash = 'anonymous';
                    }
                })();

                // Call main UI initialization
                try {
                    if (typeof initIlanaUI === 'function') {
                        initIlanaUI();
                    }
                } catch (e) {
                    console.error('Error initializing Ilana UI:', e);
                }

                // Safe call to debug helper if available (dev only)
                if (window.debugFixBackdrop && (window.__ILANA_DEBUG__ || location.search.includes('ilana_debug=1'))) {
                    window.debugFixBackdrop().then(result => {
                        console.log('üêõ Auto-ran debugFixBackdrop:', result);
                    }).catch(err => {
                        console.error('üêõ debugFixBackdrop failed:', err);
                    });
                }
            }).catch(err => {
                console.error('‚ùå Office.onReady failed:', err);
                // Fallback: try to init UI anyway
                try {
                    if (typeof initIlanaUI === 'function') {
                        initIlanaUI();
                    }
                } catch (e) {
                    console.error('Fallback UI init failed:', e);
                }
            });
        } else {
            console.warn('‚ö†Ô∏è Office.onReady not available ‚Äî you may be outside Office context.');
            // Fallback: init after short delay
            setTimeout(() => {
                try {
                    if (typeof initIlanaUI === 'function') {
                        initIlanaUI();
                    }
                } catch (e) {
                    console.error('Fallback UI init failed:', e);
                }
            }, 500);
        }

        // Main analysis function - selection-first only
        async function analyzeProtocol() {
            try {
                const selectedText = await getSelectedText();
                console.log(`Selected text length: ${selectedText.length}`);

                if (selectedText.length < 5) {
                    // No selection: show inline error
                    showError('Please select text to analyze (minimum 5 characters)');
                    logTelemetry({
                        event: 'no_selection_error',
                        selection_length: selectedText.length,
                        user_id_hash: window.IlanaState?.userHash || 'anonymous',
                        timestamp: new Date().toISOString()
                    });
                    return;
                }

                // Selection detected: analyze immediately
                await performAnalysis(selectedText, 'selection');
            } catch (error) {
                console.error('Analysis error:', error);
                showError(`Failed to start analysis: ${error.message}`);
            }
        }

        // Get selected text using Office.js
        async function getSelectedText() {
            try {
                return await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    context.load(selection, 'text');
                    await context.sync();
                    return selection.text || "";
                });
            } catch (error) {
                console.error('Error getting selected text:', error);
                return "";
            }
        }

        // Handle selection analysis
        async function handleSelectionAnalysis(selectedText) {
            const payload = {
                text: selectedText,
                ta: detectTherapeuticArea(selectedText)
            };
            
            const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`Selection analysis failed: ${response.status}`);
            }

            const result = await response.json();
            console.log('Selection analysis result:', result);

            if (result.result?.status === 'queued') {
                await handleQueuedJob(result.result);
            } else {
                const issues = extractSuggestionsFromResponse(result);
                displayAnalysisResults(issues, result.metadata || {});
                updateStatus(`Selection analysis complete: ${issues.length} issues found`, 'complete');
            }
        }

        // Simple therapeutic area detection
        function detectTherapeuticArea(text) {
            const textLower = text.toLowerCase();
            
            if (textLower.includes('oncology') || textLower.includes('cancer') || textLower.includes('tumor')) {
                return 'oncology';
            } else if (textLower.includes('cardio') || textLower.includes('heart')) {
                return 'cardiology';
            } else if (textLower.includes('neuro') || textLower.includes('brain')) {
                return 'neurology';
            }
            
            return 'general_medicine';
        }

        // Core analysis function with timeout and UI handling
        async function performAnalysis(text, mode) {
            const startTime = Date.now();
            const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Prevent multiple simultaneous analyses
            if (activeSpinners.has('analyze')) {
                console.warn('Analysis already in progress');
                return;
            }

            // Start spinner and telemetry
            showSpinner('analyze');
            
            // Log analyze start
            logTelemetry({
                event: 'analyze_start',
                request_id: requestId,
                mode: mode,
                selection_length: text.length,
                ta: window.IlanaState.currentTA || 'unknown',
                timestamp: new Date().toISOString()
            });

            try {
                // Detect therapeutic area and store globally
                window.IlanaState.currentTA = detectTherapeuticArea(text);
                
                const payload = {
                    text: mode === 'document_truncated' ? text.substring(0, MAX_DOC_CHARS) : text,
                    mode: mode,
                    ta: window.IlanaState.currentTA,
                    request_id: requestId
                };

                console.log(`üöÄ Calling /api/analyze with mode: ${mode}`, payload);

                // Use new fetch wrapper with timeout
                const fetchResult = await fetchWithTimeout(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload)
                }, 25000);

                if (!fetchResult.ok) {
                    // Handle structured errors from fetchWithTimeout
                    let errorMessage = fetchResult.message;
                    
                    if (fetchResult.reason === 'timeout') {
                        errorMessage = 'Analysis timed out after 25 seconds. Please try selecting smaller text or check your connection.';
                    } else if (fetchResult.reason === 'http_error') {
                        errorMessage = `Server error: ${fetchResult.message}`;
                    }
                    
                    // Log failure telemetry
                    logTelemetry({
                        event: 'analyze_end',
                        request_id: requestId,
                        latency_ms: Date.now() - startTime,
                        parse_success: false,
                        error_reason: fetchResult.reason,
                        error_code: fetchResult.error_code,
                        status_code: fetchResult.status,
                        timestamp: new Date().toISOString()
                    });
                    
                    throw new Error(errorMessage);
                }

                const result = await fetchResult.json();
                console.log('‚úÖ Analysis result:', result);
                console.log('üîç result.result:', result.result);
                console.log('üîç result.result.suggestions:', result.result?.suggestions);

                // Parse success telemetry
                const suggestions = extractSuggestionsFromResponse(result);
                console.log('üîç Extracted suggestions count:', suggestions.length);
                console.log('üîç Extracted suggestions:', suggestions);
                logTelemetry({
                    event: 'analyze_end',
                    request_id: result.request_id || requestId,
                    latency_ms: Date.now() - startTime,
                    parse_success: suggestions.length > 0,
                    suggestions_count: suggestions.length,
                    timestamp: new Date().toISOString()
                });

                // Handle response wrapper format {request_id, model_path, result}
                if (result.result && result.result.status === 'queued' && result.result.job_id) {
                    showJobQueuedMessage(result.result.job_id, result.request_id || requestId);
                } else if (suggestions.length > 0) {
                    displaySuggestions(suggestions, result.request_id || requestId, {
                        model_path: result.model_path || 'unknown',
                        start_time: startTime
                    });
                } else {
                    showError('No suggestions found in analysis result');
                }

                updateStatus('Analysis complete', 'complete');

            } catch (error) {
                console.error('‚ùå Analysis failed:', error);
                showError(error.message);
                updateStatus('Analysis failed', 'error');
                
                // Log error telemetry if not already logged
                if (!error.message.includes('timed out')) {
                    logTelemetry({
                        event: 'analyze_end',
                        request_id: requestId,
                        latency_ms: Date.now() - startTime,
                        parse_success: false,
                        error_message: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            } finally {
                hideSpinner('analyze');
            }
        }

        // Update analyze button state
        function setAnalyzeButtonState(isAnalyzing, text) {
            const analyzeButton = document.getElementById('analyzeButton');
            const buttonText = document.getElementById('analyzeButtonText');
            const spinner = document.getElementById('analyzeSpinner');

            analyzeButton.disabled = isAnalyzing;
            analyzeButton.setAttribute('aria-busy', isAnalyzing.toString());
            
            if (isAnalyzing) {
                buttonText.classList.add('hidden');
                spinner.classList.remove('hidden');
            } else {
                buttonText.classList.remove('hidden');
                spinner.classList.add('hidden');
                buttonText.textContent = text;
            }
        }

        /* --- Modal helpers & option handlers --- */

        // Ensure only one backdrop exists and that open/close logic is idempotent
        function ensureBackdrop() {
            let bd = document.querySelector('.modal-backdrop');
            if (!bd) {
                bd = document.createElement('div');
                bd.className = 'modal-backdrop';
                bd.setAttribute('role', 'presentation');
                bd.setAttribute('aria-hidden', 'true');
                // Attach listener in same scope (no inline onclick)
                bd.addEventListener('click', () => {
                    closeAnalysisModal();
                });
                document.body.appendChild(bd);
                console.log('‚ú® Created modal backdrop');
            }
            return bd;
        }

        // Open modal with proper accessibility and focus management
        function openAnalysisModal() {
            const container = document.querySelector('.modal-container');
            if (!container) return;

            const bd = ensureBackdrop();

            // Show backdrop + modal
            bd.classList.add('open');
            bd.setAttribute('aria-hidden', 'false');
            container.style.display = 'block';
            container.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');

            // Prevent background elements from being focused
            document.querySelectorAll('button, a, input, textarea, [tabindex]').forEach(el => {
                if (!container.contains(el)) {
                    el.dataset.ilanaTabIndex = el.getAttribute('tabindex') || '';
                    el.setAttribute('tabindex', '-1');
                }
            });

            // Focus first actionable element in modal
            const firstBtn = container.querySelector('.modal-option[tabindex="0"]');
            if (firstBtn) {
                firstBtn.focus();
            } else {
                // Fallback to close button
                const closeBtn = container.querySelector('.modal-close');
                if (closeBtn) closeBtn.focus();
            }

            console.log('‚úÖ Modal opened');
        }

        // Close modal and restore previous state
        function closeAnalysisModal() {
            const container = document.querySelector('.modal-container');

            // Hide modal
            if (container) {
                container.style.display = 'none';
                container.setAttribute('aria-hidden', 'true');
            }

            // Hide backdrop (but keep in DOM to avoid re-creation thrash)
            const bd = document.querySelector('.modal-backdrop');
            if (bd) {
                bd.classList.remove('open');
                bd.setAttribute('aria-hidden', 'true');
                bd.style.display = 'none'; // Ensure hidden
            }

            document.body.classList.remove('modal-open');

            // Restore previously saved tabindex
            document.querySelectorAll('[data-ilana-tab-index]').forEach(el => {
                const prev = el.dataset.ilanaTabIndex;
                if (prev === '') {
                    el.removeAttribute('tabindex');
                } else {
                    el.setAttribute('tabindex', prev);
                }
                delete el.dataset.ilanaTabIndex;
            });

            // Restore focus to analyze button
            const analyzeBtn = document.getElementById('analyzeButton');
            if (analyzeBtn) {
                analyzeBtn.disabled = false;
                analyzeBtn.removeAttribute('aria-busy');
                analyzeBtn.focus();
            }

            console.log('‚úÖ Modal closed');
        }

        // Backward compatibility
        function showAnalysisModal() {
            openAnalysisModal();
        }

        // Wire modal option handlers (attach listeners instead of inline onclick)
        function wireModalOptionHandlers() {
            const selectBtn = document.querySelector('.modal-option.select-text');
            if (selectBtn) {
                selectBtn.addEventListener('click', selectTextOption);
                console.log('  ‚úì Wired select-text handler');
            }

            // Document analysis event listeners removed - selection-only mode

            // Close button
            const closeBtn = document.querySelector('.modal-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeAnalysisModal);
                console.log('  ‚úì Wired close handler');
            }

            console.log('‚úÖ Modal handlers wired');
        }

        // Small UI helpers
        function setAnalyzeButtonBusy(isBusy) {
            const btn = document.getElementById('analyzeButton');
            if (!btn) return;
            btn.disabled = isBusy;
            btn.setAttribute('aria-busy', String(isBusy));
            // show/hide a spinner if you have one
            const spinner = document.getElementById('analyzeSpinner');
            if (spinner) spinner.style.display = isBusy ? 'inline-block' : 'none';
        }

        /* --- Option handlers --- */

        // 1) User wants to select text first (close modal and focus the doc)
        function selectTextOption() {
            // simply close modal and give user instruction
            closeAnalysisModal();
            // Optionally show a short toast
            showToast("Select text in the document, then click Analyze for fast results.");
            // If you want to automatically focus the document selection UI, try:
            try { Office.context.document.getSelectedDataAsync("text", () => {}); } catch(e) {}
        }

        // 2) Truncated sync analysis (fast)
        // Full-document analysis functions removed - selection-only mode

        // Setup keyboard handlers for accessibility
        function setupKeyboardHandlers() {
            document.addEventListener('keydown', (e) => {
                // FIXED: Guard against null modal element
                const modal = getEl('.modal-container');
                if (modal && !modal.classList.contains('hidden')) {
                    if (e.key === 'Escape') {
                        closeAnalysisModal();
                        e.preventDefault();
                    }
                }
            });
        }

        // Show error message
        function showError(message) {
            updateStatus(`Error: ${message}`, 'error');
            console.error('Error:', message);
        }

        // Display suggestions (wrapper for existing displayAnalysisResults)
        function displaySuggestions(suggestions, requestId, metadata = {}) {
            // Store metadata for telemetry
            window.IlanaState.lastRequestId = requestId;
            window.IlanaState.lastModelPath = metadata.model_path || 'unknown';
            window.IlanaState.lastAnalysisStartTime = metadata.start_time || Date.now();

            const issues = suggestions.map((suggestion, index) => ({
                id: `${requestId}_${index}`,
                type: suggestion.type || 'medical_terminology',
                severity: suggestion.severity || 'medium',
                text: suggestion.original || suggestion.text || 'Selected text',
                suggestion: suggestion.improved || suggestion.suggestion || 'Enhanced text',
                rationale: suggestion.reason || suggestion.rationale || 'AI analysis suggests improvement',
                range: suggestion.position || { start: 0, end: 20 },
                confidence: suggestion.confidence || 0.9,
                request_id: requestId
            }));

            displayAnalysisResults(issues, { request_id: requestId });
        }

        // Show job queued message
        function showJobQueuedMessage(jobId, requestId) {
            const cardsList = document.getElementById('cardsList');
            if (cardsList) {
                cardsList.innerHTML = `
                    <div class="job-queued-card" data-job-id="${jobId}">
                        <div class="job-queued-container">
                            <div class="job-queued-icon">‚è±Ô∏è</div>
                            <div class="job-queued-content">
                                <h3>Analysis Queued</h3>
                                <p>Job ID: <code>${jobId}</code></p>
                                <p>Request: <code>${requestId}</code></p>
                                <div class="job-queued-description">
                                    Your document analysis is processing in the background.
                                    Large document analysis typically takes 2-5 minutes.
                                    You can close this window and check back later.
                                </div>
                                <div class="job-queued-actions">
                                    <button onclick="checkJobStatus('${jobId}')" class="check-status-btn">
                                        Check Status
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            hideEmptyState();
            updateStatus('Analysis queued - check back in a few minutes', 'analyzing');
        }

        // Job status polling state
        const jobPollers = new Map(); // jobId -> { intervalId, attempts, backoff }

        // Check job status with resilient error handling
        async function checkJobStatus(jobId, isManualCheck = true) {
            // Defensive: Find the Check Status button for this job (if manual check)
            let checkStatusBtn = null;
            if (isManualCheck) {
                const card = document.querySelector(`.job-queued-card[data-job-id="${jobId}"]`);
                if (card) {
                    checkStatusBtn = card.querySelector('.check-status-btn');
                }
            }

            // Disable button and show spinner
            if (checkStatusBtn && !checkStatusBtn.disabled) {
                checkStatusBtn.disabled = true;
                checkStatusBtn.textContent = 'Checking...';
                checkStatusBtn.setAttribute('aria-busy', 'true');
            }

            try {
                console.log(`Checking status for job: ${jobId}`);

                // Fetch with 10s timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch(`${API_BASE_URL}/api/job-status/${jobId}`, {
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // FIXED: Handle 404 - job not found
                if (response.status === 404) {
                    console.warn(`Job ${jobId} not found (404)`);
                    stopJobPoller(jobId);
                    showJobNotFound(jobId);
                    // Telemetry: log job not found event
                    sendTelemetry('job_status_notfound', { job_id: jobId });
                    return;
                }

                // FIXED: Handle 500/503 errors with exponential backoff
                if (response.status >= 500) {
                    console.error(`Server error ${response.status} for job ${jobId}`);
                    handleJobStatusError(jobId, `Server error: ${response.status}`);
                    return;
                }

                const status = await response.json();

                if (status.status === 'completed' && status.result) {
                    stopJobPoller(jobId);
                    const suggestions = extractSuggestionsFromResponse(status.result);
                    if (suggestions.length > 0) {
                        displaySuggestions(suggestions, jobId, {
                            model_path: status.model_path || 'unknown',
                            start_time: Date.now() - (status.processing_time_ms || 0)
                        });
                        updateStatus('Analysis complete', 'complete');
                    } else {
                        showError('No suggestions found in completed analysis');
                    }
                } else if (status.status === 'failed') {
                    stopJobPoller(jobId);
                    showError(`Analysis failed: ${status.error_message || status.error || 'Unknown error'}`);
                } else {
                    // Still processing (queued/running)
                    updateStatus(`Job status: ${status.status}`, 'analyzing');
                    if (isManualCheck) {
                        const progress = status.progress ? ` (${Math.round(status.progress)}%)` : '';
                        showToast(`Job is ${status.status}${progress}. Check back in a few minutes.`);
                    }

                    // Re-enable button for manual checks
                    if (checkStatusBtn) {
                        checkStatusBtn.disabled = false;
                        checkStatusBtn.textContent = 'Check Status';
                        checkStatusBtn.removeAttribute('aria-busy');
                    }
                }
            } catch (error) {
                console.error(`Error checking job ${jobId}:`, error);

                // Handle timeout specifically
                if (error.name === 'AbortError') {
                    console.warn(`Job status check timed out for ${jobId}`);
                    handleJobStatusError(jobId, 'Request timed out');
                } else {
                    handleJobStatusError(jobId, error.message);
                }

                // Re-enable button on error
                if (checkStatusBtn) {
                    checkStatusBtn.disabled = false;
                    checkStatusBtn.textContent = 'Check Status';
                    checkStatusBtn.removeAttribute('aria-busy');
                }
            }
        }

        // Handle job status errors with exponential backoff
        function handleJobStatusError(jobId, errorMsg) {
            const poller = jobPollers.get(jobId);
            if (!poller) return;

            poller.attempts = (poller.attempts || 0) + 1;
            const maxAttempts = 5;

            if (poller.attempts >= maxAttempts) {
                console.error(`Max retry attempts (${maxAttempts}) reached for job ${jobId}`);
                stopJobPoller(jobId);
                showJobFailed(jobId, errorMsg);
            } else {
                // Exponential backoff: 2s, 4s, 8s, 16s, 32s
                poller.backoff = Math.min(2000 * Math.pow(2, poller.attempts), 32000);
                console.log(`Retry attempt ${poller.attempts}/${maxAttempts} for job ${jobId} in ${poller.backoff}ms`);
                updateStatus(`Retrying job status check (${poller.attempts}/${maxAttempts})...`, 'analyzing');
            }
        }

        // Stop job poller
        function stopJobPoller(jobId) {
            const poller = jobPollers.get(jobId);
            if (poller && poller.intervalId) {
                clearInterval(poller.intervalId);
                jobPollers.delete(jobId);
                console.log(`Stopped poller for job ${jobId}`);
            }
        }

        // Show job not found UI
        function showJobNotFound(jobId) {
            const card = document.querySelector(`.job-queued-card[data-job-id="${jobId}"]`);
            if (!card) {
                console.warn('Job card not found for jobId:', jobId);
                return;
            }

            card.innerHTML = `
                <div class="job-queued-content">
                    <h3 style="color: var(--error-red);">‚ö†Ô∏è Job Not Found</h3>
                    <p>Job ID: <code>${jobId}</code></p>
                    <p class="job-queued-description">
                        This job could not be found on the server. It may have expired or been removed.
                    </p>
                    <div class="job-queued-actions">
                        <button onclick="retryJobCreation()" class="check-status-btn">
                            Create New Job
                        </button>
                        <button onclick="analyzeProtocol()" class="check-status-btn" style="margin-left: 8px;">
                            Analyze Again
                        </button>
                    </div>
                </div>
            `;

            updateStatus('Job not found - please retry analysis', 'error');
        }

        // Retry creating a job via POST /api/queue-job
        async function retryJobCreation() {
            try {
                updateStatus('Creating new job...', 'analyzing');

                // Get the current document text (simplified - adjust as needed)
                const text = await getDocumentText();

                const response = await fetch(`${API_BASE_URL}/api/queue-job`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        mode: 'document_truncated'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to create job: ${response.status}`);
                }

                const data = await response.json();
                console.log('New job created:', data.job_id);

                // Show the new job queued message
                showJobQueuedMessage(data.job_id, data.job_id);
                showToast('New job created successfully!');

            } catch (error) {
                console.error('Error creating new job:', error);
                showError(`Failed to create new job: ${error.message}`);
            }
        }

        // Show job failed UI
        function showJobFailed(jobId, errorMsg) {
            const card = getEl(`.job-queued-card[data-job-id="${jobId}"]`);
            if (card) {
                card.innerHTML = `
                    <div class="job-queued-content">
                        <h3 style="color: var(--error-red);">‚ùå Job Failed</h3>
                        <p>Job ID: <code>${jobId}</code></p>
                        <p class="job-queued-description">
                            Analysis failed after multiple retry attempts: ${errorMsg}
                        </p>
                        <div class="job-queued-actions">
                            <button onclick="analyzeProtocol()" class="check-status-btn">
                                Retry Analysis
                            </button>
                        </div>
                    </div>
                `;
            }
            updateStatus(`Job failed: ${errorMsg}`, 'error');
        }

        // Simple telemetry sender (logs to console in dev, can extend for production)
        function sendTelemetry(eventName, data) {
            console.log(`üìä Telemetry: ${eventName}`, data);
            // TODO: Integrate with your telemetry service (e.g., Application Insights, Mixpanel)
        }

        // Display analysis results
        function displayAnalysisResults(issues, metadata) {
            // Normalize issues to handle different formats
            const normalizedIssues = issues.map(issue => normalizeIssue(issue));
            currentIssues = normalizedIssues;
            
            if (normalizedIssues.length === 0) {
                showEmptyState();
                hideNavigation();
                return;
            }

            // Update navigation
            updateNavigation(normalizedIssues);
            showNavigation();
            
            // Display cards
            displayCards(normalizedIssues);
        }

        // Update navigation counters
        function updateNavigation(issues) {
            const counts = { critical: 0, high: 0, medium: 0, low: 0 };
            
            issues.forEach(issue => {
                if (counts.hasOwnProperty(issue.severity)) {
                    counts[issue.severity]++;
                }
            });

            document.getElementById('totalIssues').textContent = `${issues.length} issues found`;
            document.getElementById('criticalCount').textContent = counts.critical + counts.high;
            document.getElementById('mediumCount').textContent = counts.medium;
            document.getElementById('lowCount').textContent = counts.low;
        }

        // Display cards in Grammarly style
        function displayCards(issues) {
            const cardsList = document.getElementById('cardsList');

            cardsList.innerHTML = issues.map((issue, index) => {
                // Get alignment scores for this issue
                const scores = getAlignmentScores(issue);

                return `
                <div class="card-wrapper">
                    <div class="full-card issue-card ${index === maximizedCard ? 'maximized' : 'minimized'}" data-issue-id="${issue.id}" onclick="toggleCard(${index})">
                        <div class="card-logo ${issue.severity}">
                            ${getSeverityIcon(issue.severity)}
                        </div>

                        <div class="alignment-badges">
                            <span class="alignment-badge compliance ${scores.compliance.state}" title="${scores.compliance.rationale}">
                                <span class="badge-icon">${scores.compliance.icon}</span>
                                <span class="badge-label">Compliance</span>
                            </span>
                            <span class="alignment-badge clarity ${scores.clarity.state}" title="${scores.clarity.rationale}">
                                <span class="badge-icon">${scores.clarity.icon}</span>
                                <span class="badge-label">Clarity</span>
                            </span>
                            <span class="alignment-badge feasibility ${scores.feasibility.state}" title="${scores.feasibility.rationale}">
                                <span class="badge-icon">${scores.feasibility.icon}</span>
                                <span class="badge-label">Feasibility</span>
                            </span>
                        </div>

                        <div class="issue-header">
                            <div class="report-list">
                                ${(() => {
                                    const origText = getOriginalText(issue);
                                    return origText ? `<span class="item-original">${origText.substring(0, 100)}${origText.length > 100 ? '...' : ''}</span>` : '';
                                })()}
                                ${(() => {
                                    const suggText = getSuggestionText(issue);
                                    return suggText ? `<span class="item-insert" onclick="highlightAndScrollToIssue('${issue.id}', event)">${suggText.substring(0, 100)}${suggText.length > 100 ? '...' : ''}</span>` : '';
                                })()}
                            </div>
                        </div>

                        ${index === maximizedCard ? `
                            <div class="full-sentence-background">
                                <strong>Recommendation:</strong><br>
                                ${getSuggestionText(issue)}
                                ${getRationaleText(issue) ? renderClinicalImpact(issue) : ''}
                                ${getRegulatorySource(issue) ? `<br><br>üìã <strong>Regulatory Reference:</strong> ${getRegulatorySource(issue)}` : ''}
                                ${issue.ta_enhanced ? `<br><br>üî¨ <strong>TA Enhanced</strong>` : ''}
                            </div>

                            <div class="card-footer">
                                <button class="card-footer-btn primary accept-btn" data-suggestion-id="${issue.id}" data-suggestion-index="${index}">
                                    <span class="btn-text">Accept Change</span>
                                    <span class="btn-spinner hidden">‚è≥</span>
                                </button>
                                <button class="card-footer-btn" onclick="dismissIssue(${index}, event)">
                                    Dismiss
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `}).join('');

            // Wire accept change buttons after rendering
            wireAcceptButtons();
        }

        // Toggle card maximized/minimized state
        function toggleCard(index) {
            const issue = currentIssues[index];

            // Reset Clinical Impact expansion state when card is toggled to minimized
            if (maximizedCard === index && issue) {
                // Card is being minimized - reset expansion state
                clinicalImpactExpanded.delete(issue.id);
            }

            maximizedCard = maximizedCard === index ? null : index;
            displayCards(currentIssues);
        }

        // Dismiss issue
        function dismissIssue(index, event) {
            event.stopPropagation();
            currentIssues.splice(index, 1);
            if (maximizedCard === index) {
                maximizedCard = null;
            } else if (maximizedCard > index) {
                maximizedCard--;
            }
            displayAnalysisResults(currentIssues, null);
        }

        // Get severity icon
        function getSeverityIcon(severity) {
            switch (severity) {
                case 'critical': return '!';
                case 'high': return '!';
                case 'medium': return '‚ñ≥';
                case 'low': return '‚óã';
                default: return '?';
            }
        }

        // Highlight and scroll to issue in document (Office.js-safe with debounce)
        async function highlightAndScrollToIssue(issueId, event) {
            if (event) event.stopPropagation();
            
            const startTime = Date.now();
            
            // Debounce: ignore repeated clicks to same issue within 500ms
            const now = Date.now();
            if (highlightDebounce.lastIssueId === issueId && 
                (now - highlightDebounce.lastClickTime) < highlightDebounce.debounceMs) {
                console.log(`üö¶ Debounced repeat click for issue: ${issueId}`);
                return;
            }
            highlightDebounce.lastIssueId = issueId;
            highlightDebounce.lastClickTime = now;

            // Log telemetry
            logTelemetry({
                event: 'locate_issue_clicked',
                issue_id: issueId,
                selection_length: 0, // Will be updated below
                frontend_duration_ms: 0 // Will be updated at end
            });

            try {
                await Word.run(async (context) => {
                    const issue = currentIssues.find(i => i.id === issueId);
                    if (!issue || !issue.text) {
                        showLocateErrorMessage("Issue data not found");
                        return;
                    }

                    // Get current selection length for telemetry
                    const selection = context.document.getSelection();
                    context.load(selection, 'text');
                    await context.sync();
                    
                    const selectionLength = selection.text ? selection.text.length : 0;

                    // Clear existing highlights efficiently (avoid large DOM operations)
                    await clearPreviousHighlights(context);
                    
                    // Yield to UI to prevent freeze
                    await new Promise(resolve => setTimeout(resolve, 50));

                    // Search for the issue text efficiently
                    const targetRange = await findIssueText(context, issue);
                    
                    if (targetRange) {
                        // Apply highlight and scroll in single operation
                        await highlightAndSelectRange(context, targetRange, issue);
                        
                        // Activate application focus
                        context.application.activate();
                        await context.sync();
                        
                        console.log(`‚úÖ Located and highlighted issue: ${issueId}`);
                    } else {
                        showLocateErrorMessage();
                    }

                    // Log final telemetry
                    logTelemetry({
                        event: 'locate_issue_clicked',
                        issue_id: issueId,
                        selection_length: selectionLength,
                        frontend_duration_ms: Date.now() - startTime
                    });
                });
            } catch (error) {
                console.error('Office.js highlighting error:', error);
                showLocateErrorMessage();
                
                // Log error telemetry
                logTelemetry({
                    event: 'locate_issue_error',
                    issue_id: issueId,
                    error: error.message,
                    frontend_duration_ms: Date.now() - startTime
                });
            }
        }

        // Clear previous highlights efficiently
        async function clearPreviousHighlights(context) {
            try {
                // Only clear highlights in visible content, not entire document
                const visibleRange = context.document.getSelection().getRange();
                context.load(visibleRange);
                await context.sync();
                
                // Clear highlights in paragraph containing selection
                const paragraph = visibleRange.paragraphs.getFirst();
                context.load(paragraph);
                await context.sync();
                
                paragraph.font.highlightColor = null;
                await context.sync();
            } catch (error) {
                console.warn('Could not clear previous highlights:', error);
                // Continue execution - this is not critical
            }
        }

        // Find issue text efficiently
        async function findIssueText(context, issue) {
            try {
                // Try exact text first (limited to reasonable length)
                let searchText = issue.text.substring(0, 80).trim();
                let searchResults = context.document.body.search(searchText, {matchCase: false});
                context.load(searchResults, 'items');
                await context.sync();

                if (searchResults.items.length > 0) {
                    return searchResults.items[0];
                }

                // If not found, try shorter text
                if (searchText.length > 20) {
                    searchText = issue.text.substring(0, 20).trim();
                    searchResults = context.document.body.search(searchText, {matchCase: false});
                    context.load(searchResults, 'items');
                    await context.sync();
                    
                    if (searchResults.items.length > 0) {
                        return searchResults.items[0];
                    }
                }

                return null;
            } catch (error) {
                console.warn('Search failed:', error);
                return null;
            }
        }

        // Apply highlight and select range efficiently
        async function highlightAndSelectRange(context, range, issue) {
            try {
                // Apply highlight color
                range.font.highlightColor = getSeverityColor(issue.severity);
                
                // Select and scroll to range (Office.js handles scroll automatically)
                range.select("Start");
                
                // Single sync for all operations
                await context.sync();
                
            } catch (error) {
                console.warn('Could not highlight range:', error);
                // Try fallback selection without highlight
                try {
                    range.select("Start");
                    await context.sync();
                } catch (fallbackError) {
                    throw new Error('Could not locate text in document view');
                }
            }
        }

        // Show user-friendly error for locate failures
        function showLocateErrorMessage(customMessage) {
            const message = customMessage || "Could not locate text in this view ‚Äî please use Find (Ctrl+F)";
            updateStatus(message, 'error');
            
            // Show inline message in the issue card
            const issueCard = event?.target?.closest('.full-card');
            if (issueCard) {
                const existingMessage = issueCard.querySelector('.locate-error-message');
                if (existingMessage) existingMessage.remove();
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 'locate-error-message';
                errorDiv.style.cssText = 'background:#fef2f2;color:#dc2626;padding:8px;margin:8px 0;border-radius:4px;font-size:12px;';
                errorDiv.textContent = message;
                issueCard.appendChild(errorDiv);
                
                // Remove message after 5 seconds
                setTimeout(() => {
                    if (errorDiv.parentNode) errorDiv.remove();
                }, 5000);
            }
        }

        // Log telemetry events
        function logTelemetry(eventData) {
            try {
                console.log('üìä Telemetry:', eventData);
                
                // Send to telemetry endpoint if available
                if (window.fetch && API_BASE_URL) {
                    fetch(`${API_BASE_URL}/api/telemetry`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(eventData)
                    }).catch(err => console.warn('Telemetry failed:', err));
                }
            } catch (error) {
                console.warn('Telemetry error:', error);
            }
        }

        // Get color for severity
        function getSeverityColor(severity) {
            switch (severity) {
                case 'critical': return '#ea1537';
                case 'high': return '#ea1537';
                case 'medium': return '#f59e0b';
                case 'low': return '#8189a9';
                default: return '#11a683';
            }
        }

        // Update status indicator
        function updateStatus(message, type) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            statusText.innerHTML = message;
            statusIndicator.className = `status-indicator ${type}`;
            statusIndicator.classList.remove('hidden');
        }

        // Show/hide navigation
        function showNavigation() {
            document.getElementById('navigationContainer').classList.remove('hidden');
        }

        function hideNavigation() {
            document.getElementById('navigationContainer').classList.add('hidden');
        }

        // Show/hide empty state
        function showEmptyState() {
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('cardsList').innerHTML = '';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').classList.add('hidden');
        }

        // ===== HYBRID API FUNCTIONS =====
        
        // Hybrid analysis with selection-first approach
        async function performHybridAnalysis(documentText) {
            // For large documents, use async document processing
            if (documentText.length > 10000) {
                return await createAsyncDocumentJob(documentText);
            }
            
            // For smaller documents, use direct analysis
            const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    text: documentText,
                    mode: 'document_chunked',
                    ta: detectTherapeuticArea(documentText)
                })
            });

            if (!response.ok) {
                throw new Error(`Hybrid analysis failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // Create async document job for large documents
        async function createAsyncDocumentJob(documentText) {
            const payload = {
                text: documentText,
                ta: detectTherapeuticArea(documentText),
                user_id_hash: window.IlanaState?.userHash || null,
                options: {
                    analysis_depth: "detailed",
                    provide_examples: true,
                    include_recommendations: true
                }
            };

            return await callOptimizeDocumentAsync(payload);
        }

        // Handle queued job with SSE streaming
        async function handleQueuedJob(jobResult) {
            const jobId = jobResult.job_id;
            updateStatus(`Job queued: ${jobId}<span class="loading-dots"></span>`, 'analyzing');

            try {
                // Use EventSource for SSE streaming
                const eventSource = new EventSource(`${API_BASE_URL}/api/stream-job/${jobId}/events`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    if (data.event_type === 'progress') {
                        updateStatus(`Processing: ${data.message}<span class="loading-dots"></span>`, 'analyzing');
                    } else if (data.event_type === 'complete') {
                        eventSource.close();
                        const issues = extractSuggestionsFromResponse(data);
                        displayAnalysisResults(issues, data.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                    } else if (data.event_type === 'error') {
                        eventSource.close();
                        throw new Error(data.message);
                    }
                };

                eventSource.onerror = function() {
                    eventSource.close();
                    // Fallback to polling
                    pollJobStatus(jobId);
                };

            } catch (error) {
                console.warn('SSE failed, falling back to polling:', error);
                await pollJobStatus(jobId);
            }
        }

        // Fallback polling for job status
        async function pollJobStatus(jobId) {
            const maxAttempts = 30;
            let attempts = 0;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/job-status/${jobId}`);
                    const jobStatus = await response.json();

                    if (jobStatus.status === 'completed') {
                        const issues = extractSuggestionsFromResponse(jobStatus.result);
                        displayAnalysisResults(issues, jobStatus.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                        return;
                    } else if (jobStatus.status === 'failed') {
                        throw new Error(jobStatus.error || 'Job processing failed');
                    }

                    updateStatus(`Processing${'.'.repeat((attempts % 3) + 1)}`, 'analyzing');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    attempts++;

                } catch (error) {
                    throw new Error(`Job polling failed: ${error.message}`);
                }
            }

            throw new Error('Job processing timeout');
        }

        // Extract suggestions from hybrid API response
        function extractSuggestionsFromResponse(response) {
            // Handle hybrid controller wrapper format
            if (response.result) {
                const result = response.result;
                
                // Handle different suggestion formats
                if (result.suggestions) {
                    if (Array.isArray(result.suggestions)) {
                        return result.suggestions;
                    } else if (result.suggestions.suggestions) {
                        return result.suggestions.suggestions;
                    } else if (result.suggestions.raw) {
                        try {
                            const parsed = JSON.parse(result.suggestions.raw);
                            return parsed.suggestions || [];
                        } catch (e) {
                            console.warn('Failed to parse raw suggestions:', e);
                            return [];
                        }
                    }
                }

                // Handle optimize_selection with basic/enhanced suggestions
                if (result.basic_suggestions && result.basic_suggestions.suggestions) {
                    return result.basic_suggestions.suggestions;
                }
                
                return [];
            }

            // Handle direct suggestion format (fallback)
            if (response.suggestions) {
                return Array.isArray(response.suggestions) ? response.suggestions : [];
            }

            // Handle raw format (fallback)
            if (response.raw) {
                try {
                    const parsed = JSON.parse(response.raw);
                    return parsed.suggestions || [];
                } catch (e) {
                    console.warn('Failed to parse raw response:', e);
                    return [];
                }
            }

            console.warn('No suggestions found in response:', response);
            return [];
        }

        // Simple therapeutic area detection
        function detectTherapeuticArea(text) {
            const textLower = text.toLowerCase();

            if (textLower.includes('oncology') || textLower.includes('cancer') || textLower.includes('tumor')) {
                return 'oncology';
            } else if (textLower.includes('cardio') || textLower.includes('heart')) {
                return 'cardiology';
            } else if (textLower.includes('neuro') || textLower.includes('brain')) {
                return 'neurology';
            }

            return 'general_medicine';
        }

        // ===== ACCEPT CHANGE FUNCTIONALITY =====

        // Store undo state for accepted changes
        const undoStateMap = new Map();
        let currentUndoToast = null;

        // Initialize accept change handlers
        function initializeAcceptChangeHandlers() {
            // Will attach event listeners after cards are rendered
            console.log('‚úÖ Accept change handlers ready');
        }

        // Wire accept buttons after cards are rendered
        function wireAcceptButtons() {
            const acceptButtons = document.querySelectorAll('.accept-btn');
            acceptButtons.forEach(button => {
                // Remove existing listener if any
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);

                // Always use acceptSuggestionHandler (legacy RAG pipeline)
                newButton.addEventListener('click', acceptSuggestionHandler);
            });
            console.log(`‚úÖ Wired ${acceptButtons.length} accept buttons (using router)`);
        }

        // Handle accept change button click
        async function handleAcceptChange(event) {
            event.stopPropagation();

            const button = event.currentTarget;
            const suggestionId = button.getAttribute('data-suggestion-id');
            const suggestionIndex = parseInt(button.getAttribute('data-suggestion-index'));

            const suggestion = currentIssues[suggestionIndex];
            if (!suggestion) {
                console.error('Suggestion not found:', suggestionIndex);
                return;
            }

            // Disable button and show spinner
            button.disabled = true;
            const btnText = button.querySelector('.btn-text');
            const btnSpinner = button.querySelector('.btn-spinner');
            if (btnText) btnText.classList.add('hidden');
            if (btnSpinner) btnSpinner.classList.remove('hidden');

            try {
                const originalText = getOriginalText(suggestion);
                const improvedText = getSuggestionText(suggestion);

                console.log('üîÑ Accepting change:', { suggestionId, originalText: originalText.substring(0, 50), improvedText: improvedText.substring(0, 50) });

                // Perform text replacement using Office.js
                const replaceResult = await replaceTextInDocument(originalText, improvedText);

                if (replaceResult.success) {
                    const acceptedAt = new Date().toISOString();
                    const acceptLatencyMs = Date.now() - (window.IlanaState.lastAnalysisStartTime || Date.now());

                    // Store undo state with full suggestion object
                    undoStateMap.set(suggestionId, {
                        suggestionIndex,
                        originalText,
                        improvedText,
                        range: replaceResult.range,
                        timestamp: acceptedAt,
                        suggestion: suggestion  // Store full suggestion for undo telemetry
                    });

                    // Mark card as accepted
                    markCardAsAccepted(suggestionIndex, suggestionId);

                    // Show undo toast
                    showUndoToast(suggestionId);

                    // LOG TELEMETRY: suggestion_accepted
                    logTelemetry({
                        event: 'suggestion_accepted',
                        suggestion_id: suggestionId,
                        request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                        user_id_hash: window.IlanaState.userHash || 'anonymous',
                        ta: window.IlanaState.currentTA || 'general_medicine',
                        phase: 'production',
                        model_path: window.IlanaState.lastModelPath || 'unknown',
                        analysis_mode: 'legacy',
                        latency_ms: acceptLatencyMs,
                        accepted_at: acceptedAt,
                        original_text_hash: await hashString(originalText),
                        improved_text_hash: await hashString(improvedText),
                        confidence: suggestion.confidence || 0.9,
                        severity: suggestion.severity || 'medium',
                        suggestion_type: suggestion.type || 'medical_terminology'
                    });

                    // Send reinforcement signal (non-blocking)
                    sendReinforcementSignal({
                        suggestion_id: suggestionId,
                        request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                        user_id_hash: window.IlanaState.userHash || 'anonymous',
                        ta: window.IlanaState.currentTA || 'general_medicine',
                        phase: 'production',
                        action: 'accept',
                        timestamp: acceptedAt,
                        original_text: originalText,
                        improved_text: improvedText,
                        context_snippet: extractContextSnippet(originalText, 100)
                    });

                    console.log('‚úÖ Change accepted successfully');
                } else {
                    // Replacement failed
                    console.warn('‚ö†Ô∏è Could not find text to replace');
                    showToast('Could not find original text ‚Äî please locate it manually.');
                }
            } catch (error) {
                console.error('‚ùå Error accepting change:', error);
                showError(`Failed to accept change: ${error.message}`);
            } finally {
                // Re-enable button
                button.disabled = false;
                if (btnText) btnText.classList.remove('hidden');
                if (btnSpinner) btnSpinner.classList.add('hidden');
            }
        }

        // Replace text in document using Office.js
        async function replaceTextInDocument(originalText, improvedText) {
            try {
                return await Word.run(async (context) => {
                    const body = context.document.body;
                    const searchResults = body.search(originalText, {
                        matchCase: false,
                        matchWholeWord: false
                    });

                    context.load(searchResults, 'items');
                    await context.sync();

                    if (searchResults.items.length > 0) {
                        const firstRange = searchResults.items[0];
                        firstRange.insertText(improvedText, 'Replace');
                        await context.sync();

                        console.log('‚úÖ Text replaced in document');
                        return { success: true, range: firstRange };
                    } else {
                        console.warn('‚ö†Ô∏è Text not found in document');
                        return { success: false };
                    }
                });
            } catch (error) {
                console.error('‚ùå Office.js replace error:', error);
                throw error;
            }
        }

        // Mark card as accepted visually
        function markCardAsAccepted(suggestionIndex, suggestionId) {
            const card = document.querySelector(`[data-issue-id="${suggestionId}"]`);
            if (!card) return;

            // Add accepted class
            card.classList.add('accepted');

            // Add accepted badge to header
            const header = card.querySelector('.issue-header');
            if (header && !header.querySelector('.accepted-badge')) {
                const badge = document.createElement('span');
                badge.className = 'accepted-badge';
                badge.textContent = 'ACCEPTED';

                const timestamp = document.createElement('span');
                timestamp.className = 'accepted-timestamp';
                timestamp.textContent = new Date().toLocaleTimeString();

                header.appendChild(badge);
                header.appendChild(timestamp);
            }

            // Replace accept button with accepted state
            const acceptBtn = card.querySelector('.accept-btn');
            if (acceptBtn) {
                const btnText = acceptBtn.querySelector('.btn-text');
                if (btnText) {
                    btnText.textContent = '‚úì Accepted';
                }
                acceptBtn.disabled = true;
                acceptBtn.style.background = '#dcedc8';
                acceptBtn.style.color = '#33691e';
                acceptBtn.style.borderColor = '#aed581';
            }
        }

        // Show undo toast
        function showUndoToast(suggestionId) {
            // Remove existing toast if any
            if (currentUndoToast) {
                currentUndoToast.remove();
                currentUndoToast = null;
            }

            // Create toast
            const toast = document.createElement('div');
            toast.className = 'undo-toast';
            toast.innerHTML = `
                <span class="undo-toast-text">Change accepted</span>
                <button class="undo-toast-btn" data-suggestion-id="${suggestionId}">Undo</button>
            `;

            document.body.appendChild(toast);
            currentUndoToast = toast;

            // Wire undo button
            const undoBtn = toast.querySelector('.undo-toast-btn');
            undoBtn.addEventListener('click', () => handleUndo(suggestionId));

            // Auto-hide after 10 seconds
            setTimeout(() => {
                hideUndoToast(toast);
            }, 10000);
        }

        // Hide undo toast
        function hideUndoToast(toast) {
            if (!toast) return;

            toast.classList.add('hiding');
            setTimeout(() => {
                toast.remove();
                if (currentUndoToast === toast) {
                    currentUndoToast = null;
                }
            }, 300);
        }

        // Handle undo
        async function handleUndo(suggestionId) {
            const undoState = undoStateMap.get(suggestionId);
            if (!undoState) {
                console.warn('No undo state for suggestion:', suggestionId);
                return;
            }

            try {
                console.log('üîÑ Undoing change:', suggestionId);

                // Revert text change
                await replaceTextInDocument(undoState.improvedText, undoState.originalText);

                const undoneAt = new Date().toISOString();
                const acceptedTimestamp = new Date(undoState.timestamp).getTime();
                const timeToUndoMs = Date.now() - acceptedTimestamp;

                // LOG TELEMETRY: suggestion_undone
                const suggestion = undoState.suggestion || {};
                logTelemetry({
                    event: 'suggestion_undone',
                    suggestion_id: suggestionId,
                    request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                    user_id_hash: window.IlanaState.userHash || 'anonymous',
                    ta: window.IlanaState.currentTA || 'general_medicine',
                    phase: 'production',
                    undone_at: undoneAt,
                    time_to_undo_ms: timeToUndoMs,
                    original_text_hash: await hashString(undoState.originalText),
                    improved_text_hash: await hashString(undoState.improvedText),
                    suggestion_type: suggestion.type || 'medical_terminology',
                    severity: suggestion.severity || 'medium'
                });

                // Send RL negative feedback (non-blocking)
                sendRLFeedback({
                    suggestion_id: suggestionId,
                    action: 'undo',
                    reason: 'user_undo',
                    timestamp: undoneAt,
                    request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                    user_id_hash: window.IlanaState.userHash || 'anonymous',
                    ta: window.IlanaState.currentTA || 'general_medicine',
                    phase: 'production',
                    original_text_hash: await hashString(undoState.originalText),
                    improved_text_hash: await hashString(undoState.improvedText),
                    context_snippet: extractContextSnippet(undoState.originalText, 100),
                    redactPHI: true
                });

                // Remove accepted state from card
                const card = document.querySelector(`[data-issue-id="${suggestionId}"]`);
                if (card) {
                    card.classList.remove('accepted');

                    // Remove badge
                    const badge = card.querySelector('.accepted-badge');
                    const timestamp = card.querySelector('.accepted-timestamp');
                    if (badge) badge.remove();
                    if (timestamp) timestamp.remove();

                    // Restore accept button
                    const acceptBtn = card.querySelector('.accept-btn');
                    if (acceptBtn) {
                        const btnText = acceptBtn.querySelector('.btn-text');
                        if (btnText) {
                            btnText.textContent = 'Accept Change';
                        }
                        acceptBtn.disabled = false;
                        acceptBtn.style.background = '';
                        acceptBtn.style.color = '';
                        acceptBtn.style.borderColor = '';
                    }
                }

                // Remove undo state
                undoStateMap.delete(suggestionId);

                // Hide toast
                if (currentUndoToast) {
                    hideUndoToast(currentUndoToast);
                }

                console.log('‚úÖ Change undone successfully');
            } catch (error) {
                console.error('‚ùå Error undoing change:', error);
                showError(`Failed to undo change: ${error.message}`);
            }
        }

        // Extract context snippet (PHI-redacted snippet around text)
        function extractContextSnippet(text, maxLength) {
            if (text.length <= maxLength) {
                return text;
            }
            // Take first portion for context
            return text.substring(0, maxLength) + '...';
        }

        // Hash string using SHA-256 for privacy (telemetry, user IDs)
        async function hashString(text) {
            if (!text) return '';
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                console.warn('Hash error:', error);
                return 'hash_error';
            }
        }

        // Send reinforcement signal to backend (non-blocking)
        async function sendReinforcementSignal(payload) {
            const url = `${API_BASE_URL}/api/reinforce`;

            // Add redactPHI flag
            const enrichedPayload = {
                ...payload,
                redactPHI: true,
                analysis_mode: 'legacy'
            };

            console.log('üì° Sending reinforcement signal:', enrichedPayload);

            // Retry logic (3 attempts)
            const maxRetries = 3;
            let attempt = 0;

            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(enrichedPayload),
                        signal: AbortSignal.timeout(5000) // 5 second timeout
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ Reinforcement signal sent:', result);

                        // Log telemetry
                        logTelemetry({
                            event: 'reinforcement_sent',
                            suggestion_id: payload.suggestion_id,
                            action: payload.action,
                            success: true
                        });
                        return;
                    } else {
                        console.warn(`‚ö†Ô∏è Reinforcement API returned ${response.status}`);
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Reinforcement attempt ${attempt + 1} failed:`, error.message);
                }

                attempt++;
                if (attempt < maxRetries) {
                    // Exponential backoff
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                }
            }

            // All retries failed - log but don't block UI
            console.error('‚ùå Failed to send reinforcement signal after 3 attempts');
            logTelemetry({
                event: 'reinforcement_failed',
                suggestion_id: payload.suggestion_id,
                action: payload.action,
                success: false
            });
        }

        // Send lightweight RL feedback (e.g., undo signal) to backend (non-blocking)
        async function sendRLFeedback(payload) {
            const url = `${API_BASE_URL}/api/rl/feedback`;

            // Ensure redactPHI flag is set
            if (!payload.redactPHI) {
                console.error('‚ùå sendRLFeedback: redactPHI flag must be true');
                return;
            }

            console.log('üì° Sending RL feedback:', payload);

            // Retry logic (3 attempts)
            const maxRetries = 3;
            let attempt = 0;

            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload),
                        signal: AbortSignal.timeout(5000) // 5 second timeout
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ RL feedback sent:', result);

                        // Log telemetry
                        logTelemetry({
                            event: 'rl_feedback_sent',
                            suggestion_id: payload.suggestion_id,
                            action: payload.action,
                            reason: payload.reason,
                            success: true
                        });
                        return;
                    } else {
                        console.warn(`‚ö†Ô∏è RL feedback API returned ${response.status}`);
                    }
                } catch (error) {
                    console.warn(`‚ö†Ô∏è RL feedback attempt ${attempt + 1} failed:`, error.message);
                }

                attempt++;
                if (attempt < maxRetries) {
                    // Exponential backoff
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                }
            }

            // All retries failed - log but don't block UI
            console.error('‚ùå Failed to send RL feedback after 3 attempts');
            logTelemetry({
                event: 'rl_feedback_failed',
                suggestion_id: payload.suggestion_id,
                action: payload.action,
                reason: payload.reason,
                success: false
            });
        }

        // ===== ACCEPT HANDLER WITH COMPREHENSIVE TELEMETRY (Legacy RAG Pipeline) =====

        /**
         * acceptSuggestionHandler - NEW Accept Change handler with full telemetry
         *
         * Improvements over handleAcceptChange:
         * - Comprehensive telemetry logging (suggestion_accepted event)
         * - All required fields: suggestion_id, request_id, user_id_hash, ta, phase, model_path,
         *   analysis_mode, latency_ms, accepted_at, original_text_hash, improved_text_hash,
         *   confidence, severity, suggestion_type
         * - Correct endpoint usage: /api/reinforce for accepts
         * - Full PHI protection (hashes only, no raw text)
         * - Non-blocking RL feedback with retry logic
         * - Stores full suggestion object in undo buffer for complete undo telemetry
         */
        async function acceptSuggestionHandler(event) {
            const btn = event.currentTarget;
            const suggestionId = btn.dataset.suggestionId;
            const suggestionIndex = parseInt(btn.dataset.suggestionIndex);
            const card = btn.closest('.full-card');

            if (!card) {
                console.error('‚ùå Card not found for suggestion:', suggestionId);
                return;
            }

            // Get suggestion from currentIssues
            const suggestion = currentIssues[suggestionIndex];
            if (!suggestion) {
                console.error('‚ùå Suggestion not found at index:', suggestionIndex);
                return;
            }

            // Extract text using DOM (.item-original / .item-insert)
            const originalText = card.querySelector('.item-original')?.innerText || "";
            const improvedText = card.querySelector('.item-insert')?.innerText || "";

            if (!originalText || !improvedText) {
                console.error('‚ùå Missing original or improved text');
                showToast('Cannot accept change: missing text');
                return;
            }

            // Disable button and show loading
            btn.disabled = true;
            btn.classList.add('loading');
            const btnText = btn.querySelector('.btn-text');
            const btnSpinner = btn.querySelector('.btn-spinner');
            if (btnText) btnText.classList.add('hidden');
            if (btnSpinner) btnSpinner.classList.remove('hidden');

            const acceptedAt = new Date().toISOString();
            const acceptedTimestamp = Date.now();

            try {
                console.log('üîÑ Accepting change:', { suggestionId, originalText: originalText.substring(0, 50), improvedText: improvedText.substring(0, 50) });

                // Perform text replacement using Office.js
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const searchResults = body.search(originalText, { matchCase: false, matchWholeWord: false });
                    context.load(searchResults, 'items');
                    await context.sync();

                    if (searchResults.items.length > 0) {
                        const firstRange = searchResults.items[0];
                        firstRange.insertText(improvedText, 'Replace');
                        await context.sync();

                        console.log('‚úÖ Text replaced successfully');

                        // Calculate latency
                        const acceptLatencyMs = Date.now() - (window.IlanaState.lastAnalysisStartTime || Date.now());

                        // Store undo info with FULL suggestion object
                        window._ilana_undo = {
                            suggestionId,
                            suggestionIndex,
                            originalText,
                            improvedText,
                            timestamp: acceptedTimestamp,
                            acceptedAt,
                            suggestion: suggestion  // Store full suggestion for undo telemetry
                        };

                        // Mark card as accepted visually
                        card.classList.add('accepted');
                        const footer = card.querySelector('.card-footer');
                        if (footer) {
                            footer.innerHTML = `<button class="card-footer-btn accepted-badge">Accepted ‚úì</button>`;
                        }

                        // LOG COMPREHENSIVE TELEMETRY: suggestion_accepted
                        logTelemetry({
                            event: 'suggestion_accepted',
                            suggestion_id: suggestionId,
                            request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                            user_id_hash: window.IlanaState.userHash || 'anonymous',
                            ta: window.IlanaState.currentTA || 'general_medicine',
                            phase: 'production',
                            model_path: window.IlanaState.lastModelPath || 'unknown',
                            analysis_mode: 'legacy',
                            latency_ms: acceptLatencyMs,
                            accepted_at: acceptedAt,
                            original_text_hash: await hashString(originalText),
                            improved_text_hash: await hashString(improvedText),
                            confidence: suggestion.confidence || 0.9,
                            severity: suggestion.severity || 'medium',
                            suggestion_type: suggestion.type || 'medical_terminology',
                            handler_version: 'acceptSuggestionHandler_v1'
                        });

                        // Show undo toast (10 second window)
                        showUndoToast(() => doUndoFixed(window._ilana_undo));

                        // Send RL positive feedback to /api/reinforce (non-blocking)
                        // Uses existing sendReinforcementSignal with retry logic
                        sendReinforcementSignal({
                            suggestion_id: suggestionId,
                            request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                            user_id_hash: window.IlanaState.userHash || 'anonymous',
                            ta: window.IlanaState.currentTA || 'general_medicine',
                            phase: 'production',
                            action: 'accept',
                            timestamp: acceptedAt,
                            original_text: originalText,  // sendReinforcementSignal handles PHI
                            improved_text: improvedText,
                            context_snippet: extractContextSnippet(originalText, 200)
                        }).catch(e => console.warn('‚ö†Ô∏è RL feedback failed:', e));

                        console.log('‚úÖ Change accepted successfully');

                    } else {
                        // Text not found in document
                        console.warn('‚ö†Ô∏è Could not find original text to replace');
                        showToast("Couldn't find original text to replace. Please locate it first.");
                    }
                });

            } catch (err) {
                console.error('‚ùå Accept failed:', err);
                showToast('Accept failed: ' + (err.message || err));

                // Log error telemetry
                logTelemetry({
                    event: 'suggestion_accept_error',
                    suggestion_id: suggestionId,
                    error: err.message || String(err),
                    handler_version: 'acceptSuggestionHandler_v1'
                });

            } finally {
                // Re-enable button
                btn.disabled = false;
                btn.classList.remove('loading');
                if (btnText) btnText.classList.remove('hidden');
                if (btnSpinner) btnSpinner.classList.add('hidden');
            }
        }

        /**
         * doUndoFixed - FIXED Undo handler with comprehensive telemetry
         *
         * Improvements over doUndo:
         * - Logs suggestion_undone telemetry event
         * - Calculates time_to_undo_ms accurately
         * - Sends RL negative feedback to /api/rl/feedback (not /api/reinforce)
         * - Includes all required fields: suggestion_id, request_id, user_id_hash, ta, phase,
         *   undone_at, time_to_undo_ms, original_text_hash, improved_text_hash,
         *   suggestion_type, severity, reason: 'user_undo'
         * - Full PHI protection with redactPHI: true
         */
        async function doUndoFixed(undoInfo) {
            if (!undoInfo) {
                console.warn('‚ö†Ô∏è No undo info available');
                return;
            }

            try {
                console.log('üîÑ Undoing change:', undoInfo.suggestionId);

                // Revert text change using Office.js
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const searchResults = body.search(undoInfo.improvedText, { matchCase: false, matchWholeWord: false });
                    context.load(searchResults, 'items');
                    await context.sync();

                    if (searchResults.items.length > 0) {
                        searchResults.items[0].insertText(undoInfo.originalText, 'Replace');
                        await context.sync();

                        const undoneAt = new Date().toISOString();
                        const timeToUndoMs = Date.now() - undoInfo.timestamp;

                        // LOG COMPREHENSIVE TELEMETRY: suggestion_undone
                        const suggestion = undoInfo.suggestion || {};
                        logTelemetry({
                            event: 'suggestion_undone',
                            suggestion_id: undoInfo.suggestionId,
                            request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                            user_id_hash: window.IlanaState.userHash || 'anonymous',
                            ta: window.IlanaState.currentTA || 'general_medicine',
                            phase: 'production',
                            undone_at: undoneAt,
                            time_to_undo_ms: timeToUndoMs,
                            original_text_hash: await hashString(undoInfo.originalText),
                            improved_text_hash: await hashString(undoInfo.improvedText),
                            suggestion_type: suggestion.type || 'medical_terminology',
                            severity: suggestion.severity || 'medium',
                            handler_version: 'doUndoFixed_v1'
                        });

                        // Send RL NEGATIVE feedback to /api/rl/feedback (not /api/reinforce)
                        // Uses existing sendRLFeedback with retry logic
                        sendRLFeedback({
                            suggestion_id: undoInfo.suggestionId,
                            action: 'undo',
                            reason: 'user_undo',
                            timestamp: undoneAt,
                            request_id: suggestion.request_id || window.IlanaState.lastRequestId,
                            user_id_hash: window.IlanaState.userHash || 'anonymous',
                            ta: window.IlanaState.currentTA || 'general_medicine',
                            phase: 'production',
                            original_text_hash: await hashString(undoInfo.originalText),
                            improved_text_hash: await hashString(undoInfo.improvedText),
                            context_snippet: extractContextSnippet(undoInfo.originalText, 200),
                            redactPHI: true
                        }).catch(e => console.warn('‚ö†Ô∏è RL undo feedback failed:', e));

                        console.log('‚úÖ Change undone successfully');

                    } else {
                        console.warn('‚ö†Ô∏è Could not find changed text to undo');
                        showToast('Could not find changed text to undo.');
                    }
                });

            } catch (e) {
                console.error('‚ùå Undo failed:', e);
                showToast('Undo failed: ' + (e.message || e));

                // Log error telemetry
                logTelemetry({
                    event: 'suggestion_undo_error',
                    suggestion_id: undoInfo.suggestionId,
                    error: e.message || String(e),
                    handler_version: 'doUndoFixed_v1'
                });
            }
        }

        // Hybrid mode switching removed - always use legacy RAG pipeline with acceptSuggestionHandler

        // Show toast notification
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'undo-toast';
            toast.innerHTML = `<span class="undo-toast-text">${message}</span>`;
            document.body.appendChild(toast);

            setTimeout(() => {
                hideUndoToast(toast);
            }, 3000);
        }

        // ===== TA ON-DEMAND ENHANCEMENT =====
        
        // Enhanced suggestion with TA-aware rewriting
        async function enhanceSuggestionWithTA(issue) {
            if (!issue.text || !issue.suggestion) return issue;

            try {
                const response = await fetch(`${API_BASE_URL}/api/generate-rewrite-ta`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        text: issue.text,
                        ta: detectTherapeuticArea(issue.text),
                        context: 'protocol_enhancement',
                        suggestion_id: issue.id
                    })
                });

                if (response.status === 202) {
                    // TA enhancement queued
                    const queuedResult = await response.json();
                    issue.ta_enhancement = {
                        status: 'queued',
                        message: queuedResult.message,
                        suggestion_id: queuedResult.suggestion_id
                    };
                    return issue;
                }

                if (!response.ok) {
                    console.warn('TA enhancement failed, using original suggestion');
                    return issue;
                }

                const taResult = await response.json();
                
                // Enhance the issue with TA-aware improvements
                issue.suggestion = taResult.improved || issue.suggestion;
                issue.rationale = taResult.rationale || issue.rationale;
                issue.regulatory_source = taResult.sources ? taResult.sources.join(', ') : issue.regulatory_source;
                issue.ta_enhanced = true;

                return issue;

            } catch (error) {
                console.warn('TA enhancement error:', error);
                return issue;
            }
        }

        // ===== SUGGESTION FORMAT HELPERS =====
        
        // Get original text from different suggestion formats
        function getOriginalText(issue) {
            if (!issue) return '';
            return issue.text || issue.original || issue.originalText || issue.original_text || '';
        }

        // Get suggestion text from different formats
        function getSuggestionText(issue) {
            if (!issue) return '';
            return issue.suggestion || issue.improved || issue.suggestedText || issue.improved_text || '';
        }

        // Get rationale text from different formats
        function getRationaleText(issue) {
            return issue.rationale || issue.reason || issue.complianceRationale || '';
        }

        // Get regulatory source from different formats
        function getRegulatorySource(issue) {
            return issue.regulatory_source || issue.fdaReference || issue.emaReference || '';
        }

        // ===== CLINICAL IMPACT EXPAND/COLLAPSE HELPERS =====

        // Check if Clinical Impact text appears truncated by backend
        function isClinicalImpactTruncated(text) {
            if (!text) return false;

            const trimmedText = text.trim();

            // Check for ellipsis
            if (trimmedText.endsWith('...') || trimmedText.endsWith('‚Ä¶')) {
                return true;
            }

            // Check if ends mid-word (no ending punctuation)
            const lastChar = trimmedText[trimmedText.length - 1];
            const endsWithPunctuation = /[.!?;:]/.test(lastChar);

            // Check if last "word" looks incomplete (very short or no space before it)
            const words = trimmedText.split(/\s+/);
            const lastWord = words[words.length - 1];

            if (!endsWithPunctuation && lastWord.length < 3) {
                return true; // Likely cut off mid-word
            }

            return false;
        }

        // Get truncated version of Clinical Impact text (300 chars)
        function getTruncatedClinicalImpact(text) {
            if (!text || text.length <= 300) {
                return text;
            }

            // Truncate at 300 chars, but try to break at word boundary
            let truncated = text.substring(0, 300);
            const lastSpaceIndex = truncated.lastIndexOf(' ');

            if (lastSpaceIndex > 250) { // If space is reasonably close to 300
                truncated = truncated.substring(0, lastSpaceIndex);
            }

            return truncated + '...';
        }

        // Toggle Clinical Impact expand/collapse
        async function toggleClinicalImpact(suggestionId, event) {
            event.stopPropagation(); // Prevent card toggle

            const currentState = clinicalImpactExpanded.get(suggestionId) || false;
            const issue = currentIssues.find(i => i.id === suggestionId);

            if (!issue) return;

            // If expanding and text appears truncated, fetch full text
            if (!currentState && !clinicalImpactFullText.has(suggestionId)) {
                const rationaleText = getRationaleText(issue);

                if (isClinicalImpactTruncated(rationaleText)) {
                    // Fetch full text from API
                    await fetchFullClinicalImpact(suggestionId);
                } else {
                    // Use existing text as full text
                    clinicalImpactFullText.set(suggestionId, rationaleText);
                }
            }

            // Toggle state
            clinicalImpactExpanded.set(suggestionId, !currentState);

            // Re-render cards to update UI
            displayCards(currentIssues);
        }

        // Fetch full Clinical Impact text from API
        async function fetchFullClinicalImpact(suggestionId) {
            if (clinicalImpactLoading.has(suggestionId)) return;

            clinicalImpactLoading.add(suggestionId);
            displayCards(currentIssues); // Show loading state

            try {
                const response = await fetch(`${API_BASE_URL}/api/explain-suggestion`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        suggestion_id: suggestionId,
                        ta: window.IlanaState?.currentTA || 'general_medicine',
                        analysis_mode: 'legacy'
                    }),
                    signal: AbortSignal.timeout(10000) // 10 second timeout
                });

                if (response.ok) {
                    const result = await response.json();
                    const fullText = result.rationale_full || result.rationale || result.explanation || '';

                    if (fullText) {
                        clinicalImpactFullText.set(suggestionId, fullText);
                        console.log('‚úÖ Fetched full Clinical Impact for:', suggestionId);
                    } else {
                        console.warn('‚ö†Ô∏è No full text returned from API');
                    }
                } else {
                    console.warn('‚ö†Ô∏è API returned status:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Failed to fetch full Clinical Impact:', error.message);

                // Fallback: use existing text as full text
                const issue = currentIssues.find(i => i.id === suggestionId);
                if (issue) {
                    clinicalImpactFullText.set(suggestionId, getRationaleText(issue));
                }
            } finally {
                clinicalImpactLoading.delete(suggestionId);
                displayCards(currentIssues);
            }
        }

        // Render Clinical Impact section with expand/collapse
        function renderClinicalImpact(issue) {
            const rationaleText = getRationaleText(issue);
            if (!rationaleText) return '';

            const isExpanded = clinicalImpactExpanded.get(issue.id) || false;
            const isLoading = clinicalImpactLoading.has(issue.id);
            const fullText = clinicalImpactFullText.get(issue.id);
            const needsTruncation = rationaleText.length > 300;

            // Determine which text to display
            let displayText;
            if (isExpanded) {
                displayText = fullText || rationaleText;
            } else if (needsTruncation) {
                displayText = getTruncatedClinicalImpact(rationaleText);
            } else {
                displayText = rationaleText;
            }

            // Build HTML
            let html = '<div class="clinical-impact-container">';
            html += '<strong>Clinical Impact:</strong> ';
            html += `<span class="clinical-impact-text ${isLoading ? 'clinical-impact-loading' : ''}">${displayText}</span>`;

            // Add Read more/Show less button if needed
            if (needsTruncation || (isExpanded && fullText)) {
                html += `
                    <button class="read-more-btn"
                            onclick="toggleClinicalImpact('${issue.id}', event)"
                            aria-expanded="${isExpanded}"
                            aria-label="${isExpanded ? 'Show less Clinical Impact text' : 'Read more Clinical Impact text'}">
                        ${isLoading ? '<span class="clinical-impact-spinner"></span> Loading...' :
                          isExpanded ? '‚ñ≤ Show less' : '‚ñº Read more'}
                    </button>
                `;
            }

            html += '</div>';
            return html;
        }

        // Get alignment scores (compliance, clarity, feasibility) with three-state ratings
        function getAlignmentScores(issue) {
            // If backend provides scores, use them
            if (issue.scores) {
                return {
                    compliance: calculateBadgeState(issue.scores.compliance * 100, issue.scores.compliance_rationale),
                    clarity: calculateBadgeState(issue.scores.clarity * 100, issue.scores.clarity_rationale),
                    feasibility: calculateBadgeState(issue.scores.feasibility * 100, issue.scores.feasibility_rationale)
                };
            }

            // Otherwise, calculate using frontend heuristics
            const originalText = getOriginalText(issue);
            const suggestionText = getSuggestionText(issue);
            const rationale = getRationaleText(issue);
            const regulatory = getRegulatorySource(issue);

            // --- COMPLIANCE SCORE (0-100) ---
            let complianceScore = 60; // Base score
            let complianceRationale = '';

            if (regulatory) {
                complianceScore += 20;
                complianceRationale = `Regulatory reference present (${regulatory.substring(0, 30)}...)`;
            } else {
                complianceRationale = 'No explicit regulatory reference';
            }

            if (issue.severity === 'critical' || issue.severity === 'high') {
                complianceScore += 10;
            }

            // Keyword analysis for compliance-related terms
            const complianceKeywords = ['consent', 'safety', 'adverse', 'monitoring', 'protocol', 'regulatory', 'fda', 'ema', 'ich'];
            const textLower = (originalText + ' ' + suggestionText + ' ' + rationale).toLowerCase();
            const keywordsFound = complianceKeywords.filter(kw => textLower.includes(kw));
            complianceScore += Math.min(keywordsFound.length * 3, 15); // +3 per keyword, max +15

            if (keywordsFound.length > 0) {
                complianceRationale += `. Contains compliance terms: ${keywordsFound.join(', ')}`;
            }

            // --- CLARITY SCORE (0-100) ---
            let clarityScore = 70; // Base score
            let clarityRationale = '';

            if (rationale) {
                clarityScore += 15;
                clarityRationale = 'Detailed rationale provided';
            } else {
                clarityRationale = 'No detailed rationale';
            }

            // Check if suggestion improves brevity
            if (suggestionText.length < originalText.length && originalText.length > 0) {
                const reduction = ((originalText.length - suggestionText.length) / originalText.length * 100).toFixed(0);
                clarityScore += 10;
                clarityRationale += `. Reduces text by ${reduction}%`;
            }

            // Penalize passive voice patterns
            const passivePatterns = /\b(is|are|was|were|be|been|being)\s+\w+(ed|en)\b/gi;
            const passiveMatches = (suggestionText.match(passivePatterns) || []).length;
            if (passiveMatches > 2) {
                clarityScore -= 10;
                clarityRationale += `. Contains ${passiveMatches} passive voice instances`;
            }

            // Penalize overly long suggestions
            if (suggestionText.length > 200) {
                clarityScore -= 5;
                clarityRationale += '. Suggestion is lengthy';
            }

            // --- FEASIBILITY SCORE (0-100) ---
            let feasibilityScore = issue.confidence ? Math.round(issue.confidence * 100) : 85;
            let feasibilityRationale = '';

            if (issue.confidence) {
                feasibilityRationale = `Model confidence: ${(issue.confidence * 100).toFixed(0)}%`;
            } else {
                feasibilityRationale = 'Default feasibility estimate';
            }

            // Check for complexity indicators
            const complexityIndicators = ['daily', 'frequent', 'multiple times', 'complex schedule', 'intricate', 'difficult', 'challenging'];
            const complexityMatches = complexityIndicators.filter(ind => textLower.includes(ind));
            if (complexityMatches.length > 0) {
                feasibilityScore -= Math.min(complexityMatches.length * 5, 15);
                feasibilityRationale += `. Complexity indicators: ${complexityMatches.join(', ')}`;
            }

            // Check for unrealistic frequency patterns
            const frequencyPatterns = /\b(hourly|every \d+ minutes|continuously)\b/gi;
            const frequencyMatches = (textLower.match(frequencyPatterns) || []).length;
            if (frequencyMatches > 0) {
                feasibilityScore -= 5;
                feasibilityRationale += '. Contains potentially unrealistic frequency';
            }

            // Clamp scores to 0-100 range
            complianceScore = Math.max(0, Math.min(100, complianceScore));
            clarityScore = Math.max(0, Math.min(100, clarityScore));
            feasibilityScore = Math.max(0, Math.min(100, feasibilityScore));

            return {
                compliance: calculateBadgeState(complianceScore, complianceRationale),
                clarity: calculateBadgeState(clarityScore, clarityRationale),
                feasibility: calculateBadgeState(feasibilityScore, feasibilityRationale)
            };
        }

        // Calculate badge state (good/warning/danger) based on score
        // Thresholds: 80+ = good, 60-79 = warning, <60 = danger
        function calculateBadgeState(score, rationale = '') {
            let state, icon;

            if (score >= 80) {
                state = 'good';
                icon = '‚úì';
            } else if (score >= 60) {
                state = 'warning';
                icon = '‚ö†';
            } else {
                state = 'danger';
                icon = '‚úó';
            }

            return {
                score: Math.round(score),
                state: state,
                icon: icon,
                rationale: rationale || `Score: ${Math.round(score)}%`
            };
        }

        // Normalize issue format for display
        function normalizeIssue(rawIssue) {
            return {
                id: rawIssue.id || `issue_${Date.now()}_${Math.random()}`,
                type: rawIssue.type || 'medical_terminology',
                severity: rawIssue.severity || 'medium',
                text: getOriginalText(rawIssue),
                suggestion: getSuggestionText(rawIssue),
                rationale: getRationaleText(rawIssue),
                regulatory_source: getRegulatorySource(rawIssue),
                confidence: rawIssue.confidence || 0.9,
                ta_enhanced: rawIssue.ta_enhanced || false,
                position: rawIssue.position || rawIssue.range || { start: 0, end: 0 },
                scores: rawIssue.scores || null  // Preserve backend scores if provided
            };
        }

        /* --- Result handler & UI helpers --- */

        function handleAnalyzeResult(wrapper) {
            // normalize wrapper: { request_id, model_path, result }
            const result = wrapper?.result || wrapper;
            if (!result) {
                showToast("No result returned from server.");
                return;
            }
            if (result.status === "queued") {
                showToast("Analysis queued (job id: " + (result.job_id || result.jobId) + ")");
                return;
            }
            const suggestions = result.suggestions || result;
            renderSuggestionCards(suggestions, wrapper.request_id || result.request_id);
        }

        function showToast(message, ms = 5000) {
            // Implement simple toast if you have one, or alert as fallback
            const t = document.getElementById('ilanaToast');
            if (t) {
                t.innerText = message;
                t.style.display = 'block';
                setTimeout(() => t.style.display = 'none', ms);
            } else {
                console.log("TOAST:", message);
                // Fallback to status update for now
                updateStatus(message, 'ready');
            }
        }

        function openJobProgressPanel(jobId) {
            // Implement showing a side panel or progress modal and call connectToJobStream(jobId)
            console.log("Opening job progress panel for job:", jobId);
            showJobQueuedMessage(jobId, 'job_' + Date.now());
        }

        async function callOptimizeDocumentAsync(payload) {
            // payload = { text, ta, user_id_hash }
            const apiBase = window.__ILANA_API_BASE__ || API_BASE_URL;
            // Prefer canonical endpoint:
            const analyzeUrl = `${apiBase}/api/analyze`;
            try {
                const resp = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: payload.text, mode: 'document_truncated', ta: payload.ta })
                });
                if (!resp.ok) {
                    // fallback to optimize-document-async for backward compatibility
                    const fallbackResp = await fetch(`${apiBase}/api/optimize-document-async`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });
                    return await fallbackResp.json();
                }
                return await resp.json();
            } catch (err) {
                console.warn("callOptimizeDocumentAsync analyze fallback: ", err);
                // Try direct optimize-document-async call as last resort
                const fallback = await fetch(`${apiBase}/api/optimize-document-async`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                return await fallback.json();
            }
        }

        function renderSuggestionCards(suggestions, requestId) {
            // Use existing displayAnalysisResults function for backward compatibility
            displayAnalysisResults(suggestions, { request_id: requestId });
        }

        // Expose functions to window object for inline onclick handlers
        window.analyzeProtocol = analyzeProtocol;
        window.checkJobStatus = checkJobStatus;
        window.retryJobCreation = retryJobCreation;
        window.toggleCard = toggleCard;
        window.highlightAndScrollToIssue = highlightAndScrollToIssue;
        window.dismissIssue = dismissIssue;
        window.toggleClinicalImpact = toggleClinicalImpact;
    </script>
</body>
</html>