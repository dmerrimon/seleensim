<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ilana</title>
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js"></script>
    
    <script>
        // Dev override for API base URL - replace with your ngrok or staging URL during dev
        window.__ILANA_API_BASE__ = "http://127.0.0.1:8000";
    </script>
    <style>
        /* Professional taskpane design system */
        
        :root {
            --primary-green: #11a683;
            --primary-green-hover: #15c894;
            --primary-red: #ea1537;
            --primary-red-hover: #f23452;
            --primary-blue: #3b82f6;
            --primary-orange: #f59e0b;
            --text-gray: #8189a9;
            --text-dark: #0e101a;
            --background-light: #f0f2fc;
            --border-light: #e4e6f2;
            --surface-white: #ffffff;
            --surface-hover: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--surface-white);
            color: var(--text-dark);
            font-size: 14px;
            line-height: 1.4;
            height: 100vh;
            overflow: hidden;
        }

        /* Main sidebar wrapper */
        .sidebar-wrapper {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .wrapper {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Header wrapper */
        .header-wrapper {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the button */
            margin-bottom: 8px;
        }

        .lens-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-dark);
            display: none; /* Hide this element */
        }

        .header-btn {
            background: var(--primary-green);
            color: var(--surface-white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            position: relative;
            z-index: 10; /* above normal content, below modal */
        }

        .header-btn:hover {
            background: var(--primary-green-hover);
        }

        .header-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Navigation container */
        .navigation-container {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
            background: var(--background-light);
        }

        .all-alerts-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .all-alerts-stats {
            color: var(--text-gray);
            font-size: 13px;
        }

        .counter-wrapper {
            display: flex;
            gap: 16px;
        }

        .counter-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .counter-number {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            min-width: 18px;
            text-align: center;
        }

        .counter-number.low {
            background: var(--text-gray);
        }

        .counter-number.medium {
            background: var(--primary-orange);
        }

        /* Scroll content */
        .scroll-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .card-wrapper {
            border-bottom: 1px solid var(--border-light);
        }

        .card-wrapper:last-child {
            border-bottom: none;
        }

        /* Full card structure */
        .full-card {
            padding: 20px;
            background: var(--surface-white);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .full-card:hover {
            background: var(--surface-hover);
        }

        .full-card.maximized {
            background: var(--background-light);
        }

        .card-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--surface-white);
        }

        .card-logo.critical {
            background: var(--primary-red);
        }

        .card-logo.high {
            background: var(--primary-red);
        }

        .card-logo.medium {
            background: var(--primary-orange);
        }

        .card-logo.low {
            background: var(--text-gray);
        }

        /* Report list - suggestion items */
        .report-list {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .item-original {
            position: relative;
            color: var(--primary-red);
            text-decoration: line-through;
            margin-right: 8px;
            font-weight: 500;
        }

        .item-original:after {
            content: '‚Üí';
            color: var(--text-gray);
            margin-left: 8px;
            text-decoration: none;
        }

        .item-insert {
            background: var(--primary-green);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-insert:hover {
            background: var(--primary-green-hover);
        }

        .item-remove {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-remove:hover {
            background: var(--primary-red-hover);
        }

        /* Full sentence background */
        .full-sentence-background {
            background: var(--background-light);
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
            font-style: italic;
            line-height: 1.4;
            color: var(--text-dark);
        }

        .full-sentence-insert {
            color: var(--primary-green);
            font-weight: 600;
        }

        .full-sentence-delete {
            color: var(--primary-red);
            text-decoration: line-through;
            font-weight: 600;
        }

        /* Card footer */
        .card-footer {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .card-footer-btn {
            background: transparent;
            border: 1px solid var(--border-light);
            color: var(--text-dark);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-footer-btn:hover {
            background: var(--surface-hover);
            border-color: var(--text-gray);
        }

        .card-footer-btn.primary {
            background: var(--primary-green);
            border-color: var(--primary-green);
            color: var(--surface-white);
        }

        .card-footer-btn.primary:hover {
            background: var(--primary-green-hover);
            border-color: var(--primary-green-hover);
        }

        /* Minimized state */
        .minimized .report-list {
            margin-bottom: 0;
        }

        .minimized .full-sentence-background,
        .minimized .card-footer {
            display: none;
        }

        /* Status indicators */
        .status-indicator {
            padding: 12px 20px;
            text-align: center;
            font-size: 13px;
            background: var(--background-light);
            color: var(--text-gray);
            border-bottom: 1px solid var(--border-light);
            display: none; /* Hide status indicator */
        }

        .status-indicator.analyzing {
            color: var(--primary-blue);
        }

        .status-indicator.complete {
            background: var(--primary-green);
            color: var(--surface-white);
        }

        .status-indicator.error {
            background: var(--primary-red);
            color: var(--surface-white);
        }

        /* Loading animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* Fix modal backdrop click interception bug */
        .analysis-modal.hidden {
            pointer-events: none;
        }

        .analysis-modal.hidden .modal-backdrop {
            pointer-events: none;
        }

        /* Spinner animation */
        .spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Modal body scroll lock */
        body.modal-open {
            overflow: hidden;
        }

        /* Analysis Modal Styles */
        .analysis-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Modal backdrop - hidden by default, explicit state control */
        .modal-backdrop {
            position: fixed;
            inset: 0; /* top:0; right:0; bottom:0; left:0 */
            background: rgba(0, 0, 0, 0.35);
            display: none;            /* hidden by default */
            pointer-events: none;     /* don't intercept clicks when hidden */
            z-index: 999;             /* below modal container */
        }

        /* When modal is open, show backdrop and allow clicks (to close) */
        .modal-backdrop.open {
            display: block;
            pointer-events: auto;
        }

        .modal-container {
            background: white;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1000; /* higher than backdrop */
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px 0;
            border-bottom: 1px solid var(--border-light);
            margin-bottom: 20px;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--text-dark);
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-gray);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background-color: var(--surface-hover);
        }

        .modal-body {
            padding: 0 24px 24px;
        }

        .modal-description {
            margin: 0 0 20px 0;
            color: var(--text-gray);
            font-size: 14px;
        }

        .modal-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .modal-option {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .modal-option:hover,
        .modal-option:focus {
            border-color: var(--primary-green);
            background: var(--surface-hover);
            outline: none;
        }

        .option-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .option-content h3 {
            margin: 0 0 4px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
        }

        .option-content p {
            margin: 0;
            font-size: 12px;
            color: var(--text-gray);
            line-height: 1.4;
        }

        .modal-warning {
            padding: 12px;
            background: var(--background-light);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-gray);
            border-left: 3px solid var(--primary-orange);
        }

        /* Job Queued Styles */
        .job-queued-container {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 24px;
            background: var(--background-light);
            border: 2px solid var(--primary-blue);
            border-radius: 8px;
            margin: 20px;
        }

        .job-queued-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .job-queued-content h3 {
            margin: 0 0 8px 0;
            color: var(--primary-blue);
            font-size: 16px;
            font-weight: 600;
        }

        .job-queued-content p {
            margin: 4px 0;
            font-size: 12px;
            color: var(--text-gray);
        }

        .job-queued-content code {
            background: var(--surface-white);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
        }

        .job-queued-description {
            margin: 12px 0;
            padding: 12px;
            background: var(--surface-white);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
            color: var(--text-dark);
        }

        .job-queued-actions {
            margin-top: 12px;
        }

        .check-status-btn {
            background: var(--primary-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .check-status-btn:hover {
            background: var(--primary-blue);
            filter: brightness(1.1);
        }

        /* Empty state */
        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-gray);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: var(--primary-green);
        }

        .empty-state-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-dark);
        }

        .empty-state-subtitle {
            font-size: 13px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- Professional sidebar wrapper -->
    <div class="sidebar-wrapper">
        <div class="wrapper">
            <!-- Header wrapper -->
            <div class="header-wrapper">
                <div class="header">
                    <div class="lens-title">Ilana</div>
                    <button id="analyzeButton" class="header-btn" onclick="analyzeProtocol()">
                        <span id="analyzeButtonText">Analyze</span>
                        <span id="analyzeSpinner" class="spinner hidden">‚è≥</span>
                    </button>
                </div>
            </div>

            <!-- Status indicator -->
            <div id="statusIndicator" class="status-indicator hidden">
                <span id="statusText"></span>
            </div>

            <!-- Navigation container -->
            <div id="navigationContainer" class="navigation-container hidden">
                <div class="all-alerts-container">
                    <div class="all-alerts-stats">
                        <span id="totalIssues">0 issues found</span>
                    </div>
                    <div class="counter-wrapper">
                        <div class="counter-content">
                            <span class="counter-number" id="criticalCount">0</span>
                            <span>Critical</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number medium" id="mediumCount">0</span>
                            <span>Medium</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number low" id="lowCount">0</span>
                            <span>Low</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scroll content -->
            <div class="scroll-content">
                <div id="cardsList"></div>
                
                <!-- Empty state -->
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">‚úì</div>
                    <div class="empty-state-title">Ready to analyze</div>
                    <div class="empty-state-subtitle">Click "Analyze" to check your protocol for compliance, clarity, and feasibility issues.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Options Modal -->
    <!-- Note: .modal-backdrop is created dynamically by ensureBackdrop() -->
    <div class="modal-container" role="dialog" aria-modal="true" aria-hidden="true" aria-labelledby="modalTitle" style="display:none;">
        <div class="modal-header">
            <h2 id="modalTitle">Analysis Options</h2>
            <button class="modal-close" aria-label="Close modal">&times;</button>
        </div>
        <div class="modal-body">
            <p class="modal-description">
                No text selection detected. How would you like to analyze your document?
            </p>
            <div class="modal-options">
                <button class="modal-option select-text" tabindex="0">
                    <div class="option-icon">üìù</div>
                    <div class="option-content">
                        <h3>Select Text First</h3>
                        <p>Select specific text to get targeted suggestions (recommended for quick analysis)</p>
                    </div>
                </button>
                <button class="modal-option truncated" tabindex="0">
                    <div class="option-icon">‚ö°</div>
                    <div class="option-content">
                        <h3>Analyze Document (Truncated)</h3>
                        <p>Fast analysis of first 20,000 characters. Results in 10-30 seconds.</p>
                    </div>
                </button>
                <button class="modal-option queue" tabindex="0">
                    <div class="option-icon">üîç</div>
                    <div class="option-content">
                        <h3>Queue Deep Analysis</h3>
                        <p>Comprehensive analysis of entire document. Runs in background, check back in 2-5 minutes.</p>
                    </div>
                </button>
            </div>
            <div class="modal-warning">
                <strong>Performance Note:</strong> Large document analysis may take longer. Select text for fastest results.
            </div>
        </div>
    </div>

    <script>
        // Pharmaceutical Protocol Analyzer - Professional Interface
        const API_BASE_URL = window.__ILANA_API_BASE__ || 'https://ilanalabs-add-in.onrender.com';
        console.log("API_BASE:", window.__ILANA_API_BASE__ || API_BASE_URL);
        const MAX_DOC_CHARS = 20000; // Default truncation limit
        let currentIssues = [];
        let maximizedCard = null;

        // Global state for current therapeutic area
        window.IlanaState = {
            currentTA: 'general_medicine'
        };

        // Debounce tracking for highlight clicks
        const highlightDebounce = {
            lastIssueId: null,
            lastClickTime: 0,
            debounceMs: 500
        };

        // Global spinner tracking
        const activeSpinners = new Set();

        // Global spinner helpers
        function showSpinner(id) {
            activeSpinners.add(id);
            console.log(`üîÑ Spinner started: ${id}`);
            
            // Update UI based on spinner type
            if (id === 'analyze') {
                setAnalyzeButtonState(true, 'Analyzing...');
            } else if (id === 'ta_enhancement') {
                const button = document.querySelector(`[data-spinner-id="${id}"]`);
                if (button) {
                    button.disabled = true;
                    button.innerHTML = '‚è≥ Loading...';
                }
            }
        }

        function hideSpinner(id) {
            activeSpinners.delete(id);
            console.log(`‚úÖ Spinner stopped: ${id}`);
            
            // Update UI based on spinner type
            if (id === 'analyze') {
                setAnalyzeButtonState(false, 'Analyze');
            } else if (id === 'ta_enhancement') {
                const button = document.querySelector(`[data-spinner-id="${id}"]`);
                if (button) {
                    button.disabled = false;
                    button.innerHTML = 'TA-Enhanced';
                }
            }
        }

        // Global fetch wrapper with timeout and error handling
        async function fetchWithTimeout(url, options = {}, timeoutMs = 25000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    return {
                        ok: false,
                        reason: 'http_error',
                        status: response.status,
                        statusText: response.statusText,
                        error_code: errorData.error_code,
                        message: errorData.message || `HTTP ${response.status}: ${response.statusText}`,
                        request_id: errorData.request_id
                    };
                }
                
                return {
                    ok: true,
                    response: response,
                    json: async () => await response.json()
                };
                
            } catch (error) {
                clearTimeout(timeoutId);
                
                if (error.name === 'AbortError') {
                    return {
                        ok: false,
                        reason: 'timeout',
                        message: `Request timed out after ${timeoutMs}ms. Please try selecting smaller text or check your connection.`,
                        timeoutMs: timeoutMs
                    };
                }
                
                return {
                    ok: false,
                    reason: 'network_error',
                    message: error.message || 'Network error occurred',
                    error: error
                };
            }
        }

        // Emergency backdrop cleanup function (accessible via console)
        window.debugFixBackdrop = function() {
            console.log('üîß Running emergency backdrop cleanup...');

            // Remove all backdrop elements and their state classes
            const backdrops = document.querySelectorAll('.modal-backdrop');
            console.log(`Found ${backdrops.length} backdrop(s)`);

            backdrops.forEach((el, index) => {
                el.classList.remove('open'); // Remove state class
                el.style.display = 'none';
                el.classList.add('hidden');
                el.remove();
                console.log(`  ‚úì Removed backdrop ${index + 1}`);
            });

            // Re-enable analyze button
            const analyzeBtn = document.getElementById('analyzeButton');
            if (analyzeBtn) {
                analyzeBtn.disabled = false;
                analyzeBtn.removeAttribute('aria-busy');
                analyzeBtn.focus();
                console.log('  ‚úì Analyze button re-enabled and focused');
            }

            // Close modal if open
            const modal = document.getElementById('analysisModal');
            if (modal) {
                modal.classList.add('hidden');
                modal.setAttribute('aria-hidden', 'true');
                // Also close backdrop if it exists
                const backdrop = modal.querySelector('.modal-backdrop');
                if (backdrop) {
                    backdrop.classList.remove('open');
                }
                console.log('  ‚úì Modal closed');
            }

            console.log('‚úÖ Emergency cleanup complete!');
            console.log('Note: Modal backdrop now uses explicit .open class for state management.');

            return {
                backdropsRemoved: backdrops.length,
                analyzeButtonFixed: !!analyzeBtn,
                modalClosed: !!modal
            };
        };

        // Initialize Office.js
        Office.onReady(() => {
            console.log('üöÄ Ilana loaded');
            console.log('üí° Debug help: Run window.debugFixBackdrop() if Analyze button is unresponsive');

            // Initialize modal system
            console.log('üìã Initializing modal system...');
            ensureBackdrop();
            wireModalOptionHandlers();

            updateStatus('Ready to analyze pharmaceutical protocols', 'complete');
            setupKeyboardHandlers();
        });

        // Main analysis function with improved flow
        async function analyzeProtocol() {
            try {
                const selectedText = await getSelectedText();
                console.log(`Selected text length: ${selectedText.length}`);
                
                if (selectedText.length > 5) {
                    // Selection detected: analyze immediately
                    await performAnalysis(selectedText, 'selection');
                } else {
                    // No selection: show modal with options
                    showAnalysisModal();
                }
            } catch (error) {
                console.error('Analysis error:', error);
                showError(`Failed to start analysis: ${error.message}`);
            }
        }

        // Get selected text using Office.js
        async function getSelectedText() {
            try {
                return await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    context.load(selection, 'text');
                    await context.sync();
                    return selection.text || "";
                });
            } catch (error) {
                console.error('Error getting selected text:', error);
                return "";
            }
        }

        // Handle selection analysis
        async function handleSelectionAnalysis(selectedText) {
            const payload = {
                text: selectedText,
                mode: 'selection',
                ta: detectTherapeuticArea(selectedText)
            };
            
            const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`Selection analysis failed: ${response.status}`);
            }

            const result = await response.json();
            console.log('Selection analysis result:', result);

            if (result.result?.status === 'queued') {
                await handleQueuedJob(result.result);
            } else {
                const issues = extractSuggestionsFromResponse(result);
                displayAnalysisResults(issues, result.metadata || {});
                updateStatus(`Selection analysis complete: ${issues.length} issues found`, 'complete');
            }
        }

        // Handle whole document analysis
        async function handleWholeDocumentAnalysis() {
            await Word.run(async (context) => {
                const body = context.document.body;
                context.load(body, 'text');
                await context.sync();

                const documentText = body.text;
                
                if (documentText.length < 10) {
                    throw new Error('Document appears to be empty or too short for analysis');
                }

                const payload = {
                    text: documentText,
                    mode: 'document',
                    ta: detectTherapeuticArea(documentText)
                };

                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Document analysis failed: ${response.status}`);
                }

                const result = await response.json();
                console.log('Document analysis result:', result);

                if (result.result?.status === 'queued') {
                    await handleQueuedJob(result.result);
                } else {
                    const issues = extractSuggestionsFromResponse(result);
                    displayAnalysisResults(issues, result.metadata || {});
                    updateStatus(`Document analysis complete: ${issues.length} issues found`, 'complete');
                }
            });
        }

        // Simple therapeutic area detection
        function detectTherapeuticArea(text) {
            const textLower = text.toLowerCase();
            
            if (textLower.includes('oncology') || textLower.includes('cancer') || textLower.includes('tumor')) {
                return 'oncology';
            } else if (textLower.includes('cardio') || textLower.includes('heart')) {
                return 'cardiology';
            } else if (textLower.includes('neuro') || textLower.includes('brain')) {
                return 'neurology';
            }
            
            return 'general_medicine';
        }

        // Core analysis function with timeout and UI handling
        async function performAnalysis(text, mode) {
            const startTime = Date.now();
            const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Prevent multiple simultaneous analyses
            if (activeSpinners.has('analyze')) {
                console.warn('Analysis already in progress');
                return;
            }

            // Start spinner and telemetry
            showSpinner('analyze');
            
            // Log analyze start
            logTelemetry({
                event: 'analyze_start',
                request_id: requestId,
                mode: mode,
                selection_length: text.length,
                ta: window.IlanaState.currentTA || 'unknown',
                timestamp: new Date().toISOString()
            });

            try {
                // Detect therapeutic area and store globally
                window.IlanaState.currentTA = detectTherapeuticArea(text);
                
                const payload = {
                    text: mode === 'document_truncated' ? text.substring(0, MAX_DOC_CHARS) : text,
                    mode: mode,
                    ta: window.IlanaState.currentTA,
                    request_id: requestId
                };

                console.log(`üöÄ Calling /api/analyze with mode: ${mode}`, payload);

                // Use new fetch wrapper with timeout
                const fetchResult = await fetchWithTimeout(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload)
                }, 25000);

                if (!fetchResult.ok) {
                    // Handle structured errors from fetchWithTimeout
                    let errorMessage = fetchResult.message;
                    
                    if (fetchResult.reason === 'timeout') {
                        errorMessage = 'Analysis timed out after 25 seconds. Please try selecting smaller text or check your connection.';
                    } else if (fetchResult.reason === 'http_error') {
                        errorMessage = `Server error: ${fetchResult.message}`;
                    }
                    
                    // Log failure telemetry
                    logTelemetry({
                        event: 'analyze_end',
                        request_id: requestId,
                        latency_ms: Date.now() - startTime,
                        parse_success: false,
                        error_reason: fetchResult.reason,
                        error_code: fetchResult.error_code,
                        status_code: fetchResult.status,
                        timestamp: new Date().toISOString()
                    });
                    
                    throw new Error(errorMessage);
                }

                const result = await fetchResult.json();
                console.log('‚úÖ Analysis result:', result);

                // Parse success telemetry
                const suggestions = extractSuggestionsFromResponse(result);
                logTelemetry({
                    event: 'analyze_end',
                    request_id: result.request_id || requestId,
                    latency_ms: Date.now() - startTime,
                    parse_success: suggestions.length > 0,
                    suggestions_count: suggestions.length,
                    timestamp: new Date().toISOString()
                });

                // Handle response wrapper format {request_id, model_path, result}
                if (result.result && result.result.status === 'queued' && result.result.job_id) {
                    showJobQueuedMessage(result.result.job_id, result.request_id || requestId);
                } else if (suggestions.length > 0) {
                    displaySuggestions(suggestions, result.request_id || requestId);
                } else {
                    showError('No suggestions found in analysis result');
                }

                updateStatus(`${mode === 'selection' ? 'Selection' : 'Document'} analysis complete`, 'complete');

            } catch (error) {
                console.error('‚ùå Analysis failed:', error);
                showError(error.message);
                updateStatus('Analysis failed', 'error');
                
                // Log error telemetry if not already logged
                if (!error.message.includes('timed out')) {
                    logTelemetry({
                        event: 'analyze_end',
                        request_id: requestId,
                        latency_ms: Date.now() - startTime,
                        parse_success: false,
                        error_message: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
            } finally {
                hideSpinner('analyze');
            }
        }

        // Update analyze button state
        function setAnalyzeButtonState(isAnalyzing, text) {
            const analyzeButton = document.getElementById('analyzeButton');
            const buttonText = document.getElementById('analyzeButtonText');
            const spinner = document.getElementById('analyzeSpinner');

            analyzeButton.disabled = isAnalyzing;
            analyzeButton.setAttribute('aria-busy', isAnalyzing.toString());
            
            if (isAnalyzing) {
                buttonText.classList.add('hidden');
                spinner.classList.remove('hidden');
            } else {
                buttonText.classList.remove('hidden');
                spinner.classList.add('hidden');
                buttonText.textContent = text;
            }
        }

        /* --- Modal helpers & option handlers --- */

        // Ensure only one backdrop exists and that open/close logic is idempotent
        function ensureBackdrop() {
            let bd = document.querySelector('.modal-backdrop');
            if (!bd) {
                bd = document.createElement('div');
                bd.className = 'modal-backdrop';
                bd.setAttribute('role', 'presentation');
                bd.setAttribute('aria-hidden', 'true');
                // Attach listener in same scope (no inline onclick)
                bd.addEventListener('click', () => {
                    closeAnalysisModal();
                });
                document.body.appendChild(bd);
                console.log('‚ú® Created modal backdrop');
            }
            return bd;
        }

        // Open modal with proper accessibility and focus management
        function openAnalysisModal() {
            const container = document.querySelector('.modal-container');
            if (!container) return;

            const bd = ensureBackdrop();

            // Show backdrop + modal
            bd.classList.add('open');
            bd.setAttribute('aria-hidden', 'false');
            container.style.display = 'block';
            container.setAttribute('aria-hidden', 'false');
            document.body.classList.add('modal-open');

            // Prevent background elements from being focused
            document.querySelectorAll('button, a, input, textarea, [tabindex]').forEach(el => {
                if (!container.contains(el)) {
                    el.dataset._ilanaTabIndex = el.getAttribute('tabindex') || '';
                    el.setAttribute('tabindex', '-1');
                }
            });

            // Focus first actionable element in modal
            const firstBtn = container.querySelector('.modal-option[tabindex="0"]');
            if (firstBtn) {
                firstBtn.focus();
            } else {
                // Fallback to close button
                const closeBtn = container.querySelector('.modal-close');
                if (closeBtn) closeBtn.focus();
            }

            console.log('‚úÖ Modal opened');
        }

        // Close modal and restore previous state
        function closeAnalysisModal() {
            const container = document.querySelector('.modal-container');

            // Hide modal
            if (container) {
                container.style.display = 'none';
                container.setAttribute('aria-hidden', 'true');
            }

            // Hide backdrop (but keep in DOM to avoid re-creation thrash)
            const bd = document.querySelector('.modal-backdrop');
            if (bd) {
                bd.classList.remove('open');
                bd.setAttribute('aria-hidden', 'true');
                bd.style.display = 'none'; // Ensure hidden
            }

            document.body.classList.remove('modal-open');

            // Restore previously saved tabindex
            document.querySelectorAll('[data-_ilana-tab-index]').forEach(el => {
                const prev = el.dataset._ilanaTabIndex;
                if (prev === '') {
                    el.removeAttribute('tabindex');
                } else {
                    el.setAttribute('tabindex', prev);
                }
                delete el.dataset._ilanaTabIndex;
            });

            // Restore focus to analyze button
            const analyzeBtn = document.getElementById('analyzeButton');
            if (analyzeBtn) {
                analyzeBtn.disabled = false;
                analyzeBtn.removeAttribute('aria-busy');
                analyzeBtn.focus();
            }

            console.log('‚úÖ Modal closed');
        }

        // Backward compatibility
        function showAnalysisModal() {
            openAnalysisModal();
        }

        // Wire modal option handlers (attach listeners instead of inline onclick)
        function wireModalOptionHandlers() {
            const selectBtn = document.querySelector('.modal-option.select-text');
            if (selectBtn) {
                selectBtn.addEventListener('click', selectTextOption);
                console.log('  ‚úì Wired select-text handler');
            }

            const truncatedBtn = document.querySelector('.modal-option.truncated');
            if (truncatedBtn) {
                truncatedBtn.addEventListener('click', analyzeTruncatedDocument);
                console.log('  ‚úì Wired truncated handler');
            }

            const queueBtn = document.querySelector('.modal-option.queue');
            if (queueBtn) {
                queueBtn.addEventListener('click', queueDeepAnalysis);
                console.log('  ‚úì Wired queue handler');
            }

            // Close button
            const closeBtn = document.querySelector('.modal-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeAnalysisModal);
                console.log('  ‚úì Wired close handler');
            }

            console.log('‚úÖ Modal handlers wired');
        }

        // Small UI helpers
        function setAnalyzeButtonBusy(isBusy) {
            const btn = document.getElementById('analyzeButton');
            if (!btn) return;
            btn.disabled = isBusy;
            btn.setAttribute('aria-busy', String(isBusy));
            // show/hide a spinner if you have one
            const spinner = document.getElementById('analyzeSpinner');
            if (spinner) spinner.style.display = isBusy ? 'inline-block' : 'none';
        }

        /* --- Option handlers --- */

        // 1) User wants to select text first (close modal and focus the doc)
        function selectTextOption() {
            // simply close modal and give user instruction
            closeAnalysisModal();
            // Optionally show a short toast
            showToast("Select text in the document, then click Analyze for fast results.");
            // If you want to automatically focus the document selection UI, try:
            try { Office.context.document.getSelectedDataAsync("text", () => {}); } catch(e) {}
        }

        // 2) Truncated sync analysis (fast)
        async function analyzeTruncatedDocument() {
            closeAnalysisModal();
            setAnalyzeButtonBusy(true);
            try {
                // Extract document text via Office.js (safest pattern)
                await Word.run(async (context) => {
                    const body = context.document.body;
                    body.load("text");
                    await context.sync();
                    let fullText = body.text || "";
                    const truncated = fullText.slice(0, 20000); // first 20k chars
                    // call backend
                    const url = (window.__ILANA_API_BASE__ || API_BASE_URL) + "/api/analyze";
                    const payload = { text: truncated, mode: "document_truncated", ta: window.IlanaState?.currentTA || null };
                    const resp = await fetchWithTimeout(url, {
                        method: "POST",
                        headers: {"Content-Type": "application/json"},
                        body: JSON.stringify(payload)
                    }, 25000);
                    if (!resp.ok) {
                        const txt = await resp.text();
                        showToast("Server error: " + resp.status + " " + txt);
                        setAnalyzeButtonBusy(false);
                        return;
                    }
                    const json = await resp.json();
                    handleAnalyzeResult(json);
                });
            } catch (err) {
                if (err.name === 'AbortError') showToast("Request timed out. Try 'Queue Deep Analysis' instead.");
                else showToast("Error during analysis: " + (err.message || err));
                console.error(err);
            } finally {
                setAnalyzeButtonBusy(false);
            }
        }

        // 3) Queue background deep analysis (async job)
        async function queueDeepAnalysis() {
            closeAnalysisModal();
            setAnalyzeButtonBusy(true);
            try {
                // Get whole document text and send to async enqueue endpoint using smart fallback
                await Word.run(async (context) => {
                    const body = context.document.body;
                    body.load("text");
                    await context.sync();
                    const fullText = body.text || "";
                    const payload = { text: fullText, ta: window.IlanaState?.currentTA || null, user_id_hash: window.IlanaState?.userHash || null };
                    
                    const json = await callOptimizeDocumentAsync(payload);
                    
                    // Expect { request_id, result: { status: "queued", job_id } } or { status: "queued", job_id }
                    if (json?.result?.status === "queued" || json?.status === "queued") {
                        const jobId = json.result?.job_id || json.job_id || json?.jobId;
                        showToast("Deep analysis queued. Job ID: " + jobId);
                        // Optionally open job progress panel
                        openJobProgressPanel(jobId);
                    } else {
                        handleAnalyzeResult(json);
                    }
                });
            } catch (err) {
                console.error(err);
                showToast("Failed to queue deep analysis: " + (err.message || err));
            } finally {
                setAnalyzeButtonBusy(false);
            }
        }

        // Get full document text
        async function getFullDocumentText() {
            return await Word.run(async (context) => {
                const body = context.document.body;
                context.load(body, 'text');
                await context.sync();
                return body.text;
            });
        }

        // Setup keyboard handlers for accessibility
        function setupKeyboardHandlers() {
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('analysisModal');
                if (!modal.classList.contains('hidden')) {
                    if (e.key === 'Escape') {
                        closeAnalysisModal();
                        e.preventDefault();
                    }
                }
            });
        }

        // Show error message
        function showError(message) {
            updateStatus(`Error: ${message}`, 'error');
            console.error('Error:', message);
        }

        // Display suggestions (wrapper for existing displayAnalysisResults)
        function displaySuggestions(suggestions, requestId) {
            const issues = suggestions.map((suggestion, index) => ({
                id: `${requestId}_${index}`,
                type: suggestion.type || 'medical_terminology',
                severity: suggestion.severity || 'medium',
                text: suggestion.original || suggestion.text || 'Selected text',
                suggestion: suggestion.improved || suggestion.suggestion || 'Enhanced text',
                rationale: suggestion.reason || suggestion.rationale || 'AI analysis suggests improvement',
                range: suggestion.position || { start: 0, end: 20 },
                confidence: suggestion.confidence || 0.9,
                request_id: requestId
            }));

            displayAnalysisResults(issues, { request_id: requestId });
        }

        // Show job queued message
        function showJobQueuedMessage(jobId, requestId) {
            const cardsList = document.getElementById('cardsList');
            if (cardsList) {
                cardsList.innerHTML = `
                    <div class="job-queued-container">
                        <div class="job-queued-icon">‚è±Ô∏è</div>
                        <div class="job-queued-content">
                            <h3>Analysis Queued</h3>
                            <p>Job ID: <code>${jobId}</code></p>
                            <p>Request: <code>${requestId}</code></p>
                            <div class="job-queued-description">
                                Your document analysis is processing in the background. 
                                Large document analysis typically takes 2-5 minutes. 
                                You can close this window and check back later.
                            </div>
                            <div class="job-queued-actions">
                                <button onclick="checkJobStatus('${jobId}')" class="check-status-btn">
                                    Check Status
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }
            hideEmptyState();
            updateStatus('Analysis queued - check back in a few minutes', 'analyzing');
        }

        // Check job status
        async function checkJobStatus(jobId) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/job-status/${jobId}`);
                const status = await response.json();
                
                if (status.status === 'completed' && status.result) {
                    const suggestions = extractSuggestionsFromResponse(status.result);
                    if (suggestions.length > 0) {
                        displaySuggestions(suggestions, jobId);
                        updateStatus('Analysis complete', 'complete');
                    } else {
                        showError('No suggestions found in completed analysis');
                    }
                } else if (status.status === 'failed') {
                    showError(`Analysis failed: ${status.error || 'Unknown error'}`);
                } else {
                    updateStatus(`Job status: ${status.status}`, 'analyzing');
                }
            } catch (error) {
                showError(`Failed to check job status: ${error.message}`);
            }
        }

        // Display analysis results
        function displayAnalysisResults(issues, metadata) {
            // Normalize issues to handle different formats
            const normalizedIssues = issues.map(issue => normalizeIssue(issue));
            currentIssues = normalizedIssues;
            
            if (normalizedIssues.length === 0) {
                showEmptyState();
                hideNavigation();
                return;
            }

            // Update navigation
            updateNavigation(normalizedIssues);
            showNavigation();
            
            // Display cards
            displayCards(normalizedIssues);
        }

        // Update navigation counters
        function updateNavigation(issues) {
            const counts = { critical: 0, high: 0, medium: 0, low: 0 };
            
            issues.forEach(issue => {
                if (counts.hasOwnProperty(issue.severity)) {
                    counts[issue.severity]++;
                }
            });

            document.getElementById('totalIssues').textContent = `${issues.length} issues found`;
            document.getElementById('criticalCount').textContent = counts.critical + counts.high;
            document.getElementById('mediumCount').textContent = counts.medium;
            document.getElementById('lowCount').textContent = counts.low;
        }

        // Display cards in Grammarly style
        function displayCards(issues) {
            const cardsList = document.getElementById('cardsList');
            
            cardsList.innerHTML = issues.map((issue, index) => `
                <div class="card-wrapper">
                    <div class="full-card ${index === maximizedCard ? 'maximized' : 'minimized'}" onclick="toggleCard(${index})">
                        <div class="card-logo ${issue.severity}">
                            ${getSeverityIcon(issue.severity)}
                        </div>
                        
                        <div class="report-list">
                            ${getOriginalText(issue) ? `<span class="item-original">${getOriginalText(issue).substring(0, 100)}${getOriginalText(issue).length > 100 ? '...' : ''}</span>` : ''}
                            <span class="item-insert" onclick="highlightAndScrollToIssue('${issue.id}', event)">${getSuggestionText(issue).substring(0, 100)}${getSuggestionText(issue).length > 100 ? '...' : ''}</span>
                        </div>
                        
                        ${index === maximizedCard ? `
                            <div class="full-sentence-background">
                                <strong>Recommendation:</strong><br>
                                ${getSuggestionText(issue)}
                                ${getRationaleText(issue) ? `<br><br><strong>Clinical Impact:</strong> ${getRationaleText(issue)}` : ''}
                                ${getRegulatorySource(issue) ? `<br><br>üìã <strong>Regulatory Reference:</strong> ${getRegulatorySource(issue)}` : ''}
                                ${issue.ta_enhanced ? `<br><br>üî¨ <strong>TA Enhanced</strong>` : ''}
                            </div>
                            
                            <div class="card-footer">
                                <button class="card-footer-btn primary" onclick="highlightAndScrollToIssue('${issue.id}', event)">
                                    Locate in Document
                                </button>
                                <button class="card-footer-btn" onclick="dismissIssue(${index}, event)">
                                    Dismiss
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        // Toggle card maximized/minimized state
        function toggleCard(index) {
            maximizedCard = maximizedCard === index ? null : index;
            displayCards(currentIssues);
        }

        // Dismiss issue
        function dismissIssue(index, event) {
            event.stopPropagation();
            currentIssues.splice(index, 1);
            if (maximizedCard === index) {
                maximizedCard = null;
            } else if (maximizedCard > index) {
                maximizedCard--;
            }
            displayAnalysisResults(currentIssues, null);
        }

        // Get severity icon
        function getSeverityIcon(severity) {
            switch (severity) {
                case 'critical': return '!';
                case 'high': return '!';
                case 'medium': return '‚ñ≥';
                case 'low': return '‚óã';
                default: return '?';
            }
        }

        // Highlight and scroll to issue in document (Office.js-safe with debounce)
        async function highlightAndScrollToIssue(issueId, event) {
            if (event) event.stopPropagation();
            
            const startTime = Date.now();
            
            // Debounce: ignore repeated clicks to same issue within 500ms
            const now = Date.now();
            if (highlightDebounce.lastIssueId === issueId && 
                (now - highlightDebounce.lastClickTime) < highlightDebounce.debounceMs) {
                console.log(`üö¶ Debounced repeat click for issue: ${issueId}`);
                return;
            }
            highlightDebounce.lastIssueId = issueId;
            highlightDebounce.lastClickTime = now;

            // Log telemetry
            logTelemetry({
                event: 'locate_issue_clicked',
                issue_id: issueId,
                selection_length: 0, // Will be updated below
                frontend_duration_ms: 0 // Will be updated at end
            });

            try {
                await Word.run(async (context) => {
                    const issue = currentIssues.find(i => i.id === issueId);
                    if (!issue || !issue.text) {
                        showLocateErrorMessage("Issue data not found");
                        return;
                    }

                    // Get current selection length for telemetry
                    const selection = context.document.getSelection();
                    context.load(selection, 'text');
                    await context.sync();
                    
                    const selectionLength = selection.text ? selection.text.length : 0;

                    // Clear existing highlights efficiently (avoid large DOM operations)
                    await clearPreviousHighlights(context);
                    
                    // Yield to UI to prevent freeze
                    await new Promise(resolve => setTimeout(resolve, 50));

                    // Search for the issue text efficiently
                    const targetRange = await findIssueText(context, issue);
                    
                    if (targetRange) {
                        // Apply highlight and scroll in single operation
                        await highlightAndSelectRange(context, targetRange, issue);
                        
                        // Activate application focus
                        context.application.activate();
                        await context.sync();
                        
                        console.log(`‚úÖ Located and highlighted issue: ${issueId}`);
                    } else {
                        showLocateErrorMessage();
                    }

                    // Log final telemetry
                    logTelemetry({
                        event: 'locate_issue_clicked',
                        issue_id: issueId,
                        selection_length: selectionLength,
                        frontend_duration_ms: Date.now() - startTime
                    });
                });
            } catch (error) {
                console.error('Office.js highlighting error:', error);
                showLocateErrorMessage();
                
                // Log error telemetry
                logTelemetry({
                    event: 'locate_issue_error',
                    issue_id: issueId,
                    error: error.message,
                    frontend_duration_ms: Date.now() - startTime
                });
            }
        }

        // Clear previous highlights efficiently
        async function clearPreviousHighlights(context) {
            try {
                // Only clear highlights in visible content, not entire document
                const visibleRange = context.document.getSelection().getRange();
                context.load(visibleRange);
                await context.sync();
                
                // Clear highlights in paragraph containing selection
                const paragraph = visibleRange.paragraphs.getFirst();
                context.load(paragraph);
                await context.sync();
                
                paragraph.font.highlightColor = null;
                await context.sync();
            } catch (error) {
                console.warn('Could not clear previous highlights:', error);
                // Continue execution - this is not critical
            }
        }

        // Find issue text efficiently
        async function findIssueText(context, issue) {
            try {
                // Try exact text first (limited to reasonable length)
                let searchText = issue.text.substring(0, 80).trim();
                let searchResults = context.document.body.search(searchText, {matchCase: false});
                context.load(searchResults, 'items');
                await context.sync();

                if (searchResults.items.length > 0) {
                    return searchResults.items[0];
                }

                // If not found, try shorter text
                if (searchText.length > 20) {
                    searchText = issue.text.substring(0, 20).trim();
                    searchResults = context.document.body.search(searchText, {matchCase: false});
                    context.load(searchResults, 'items');
                    await context.sync();
                    
                    if (searchResults.items.length > 0) {
                        return searchResults.items[0];
                    }
                }

                return null;
            } catch (error) {
                console.warn('Search failed:', error);
                return null;
            }
        }

        // Apply highlight and select range efficiently
        async function highlightAndSelectRange(context, range, issue) {
            try {
                // Apply highlight color
                range.font.highlightColor = getSeverityColor(issue.severity);
                
                // Select and scroll to range (Office.js handles scroll automatically)
                range.select("Start");
                
                // Single sync for all operations
                await context.sync();
                
            } catch (error) {
                console.warn('Could not highlight range:', error);
                // Try fallback selection without highlight
                try {
                    range.select("Start");
                    await context.sync();
                } catch (fallbackError) {
                    throw new Error('Could not locate text in document view');
                }
            }
        }

        // Show user-friendly error for locate failures
        function showLocateErrorMessage(customMessage) {
            const message = customMessage || "Could not locate text in this view ‚Äî please use Find (Ctrl+F)";
            updateStatus(message, 'error');
            
            // Show inline message in the issue card
            const issueCard = event?.target?.closest('.full-card');
            if (issueCard) {
                const existingMessage = issueCard.querySelector('.locate-error-message');
                if (existingMessage) existingMessage.remove();
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 'locate-error-message';
                errorDiv.style.cssText = 'background:#fef2f2;color:#dc2626;padding:8px;margin:8px 0;border-radius:4px;font-size:12px;';
                errorDiv.textContent = message;
                issueCard.appendChild(errorDiv);
                
                // Remove message after 5 seconds
                setTimeout(() => {
                    if (errorDiv.parentNode) errorDiv.remove();
                }, 5000);
            }
        }

        // Log telemetry events
        function logTelemetry(eventData) {
            try {
                console.log('üìä Telemetry:', eventData);
                
                // Send to telemetry endpoint if available
                if (window.fetch && API_BASE_URL) {
                    fetch(`${API_BASE_URL}/api/telemetry`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(eventData)
                    }).catch(err => console.warn('Telemetry failed:', err));
                }
            } catch (error) {
                console.warn('Telemetry error:', error);
            }
        }

        // Get color for severity
        function getSeverityColor(severity) {
            switch (severity) {
                case 'critical': return '#ea1537';
                case 'high': return '#ea1537';
                case 'medium': return '#f59e0b';
                case 'low': return '#8189a9';
                default: return '#11a683';
            }
        }

        // Update status indicator
        function updateStatus(message, type) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            statusText.innerHTML = message;
            statusIndicator.className = `status-indicator ${type}`;
            statusIndicator.classList.remove('hidden');
        }

        // Show/hide navigation
        function showNavigation() {
            document.getElementById('navigationContainer').classList.remove('hidden');
        }

        function hideNavigation() {
            document.getElementById('navigationContainer').classList.add('hidden');
        }

        // Show/hide empty state
        function showEmptyState() {
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('cardsList').innerHTML = '';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').classList.add('hidden');
        }

        // ===== HYBRID API FUNCTIONS =====
        
        // Hybrid analysis with selection-first approach
        async function performHybridAnalysis(documentText) {
            // For large documents, use async document processing
            if (documentText.length > 10000) {
                return await createAsyncDocumentJob(documentText);
            }
            
            // For smaller documents, use direct analysis
            const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    text: documentText,
                    mode: 'document_chunked',
                    ta: detectTherapeuticArea(documentText)
                })
            });

            if (!response.ok) {
                throw new Error(`Hybrid analysis failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // Create async document job for large documents
        async function createAsyncDocumentJob(documentText) {
            const payload = {
                text: documentText,
                ta: detectTherapeuticArea(documentText),
                user_id_hash: window.IlanaState?.userHash || null,
                options: {
                    analysis_depth: "detailed",
                    provide_examples: true,
                    include_recommendations: true
                }
            };

            return await callOptimizeDocumentAsync(payload);
        }

        // Handle queued job with SSE streaming
        async function handleQueuedJob(jobResult) {
            const jobId = jobResult.job_id;
            updateStatus(`Job queued: ${jobId}<span class="loading-dots"></span>`, 'analyzing');

            try {
                // Use EventSource for SSE streaming
                const eventSource = new EventSource(`${API_BASE_URL}/api/stream-job/${jobId}/events`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    if (data.event_type === 'progress') {
                        updateStatus(`Processing: ${data.message}<span class="loading-dots"></span>`, 'analyzing');
                    } else if (data.event_type === 'complete') {
                        eventSource.close();
                        const issues = extractSuggestionsFromResponse(data);
                        displayAnalysisResults(issues, data.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                    } else if (data.event_type === 'error') {
                        eventSource.close();
                        throw new Error(data.message);
                    }
                };

                eventSource.onerror = function() {
                    eventSource.close();
                    // Fallback to polling
                    pollJobStatus(jobId);
                };

            } catch (error) {
                console.warn('SSE failed, falling back to polling:', error);
                await pollJobStatus(jobId);
            }
        }

        // Fallback polling for job status
        async function pollJobStatus(jobId) {
            const maxAttempts = 30;
            let attempts = 0;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/job-status/${jobId}`);
                    const jobStatus = await response.json();

                    if (jobStatus.status === 'completed') {
                        const issues = extractSuggestionsFromResponse(jobStatus.result);
                        displayAnalysisResults(issues, jobStatus.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                        return;
                    } else if (jobStatus.status === 'failed') {
                        throw new Error(jobStatus.error || 'Job processing failed');
                    }

                    updateStatus(`Processing${'.'.repeat((attempts % 3) + 1)}`, 'analyzing');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    attempts++;

                } catch (error) {
                    throw new Error(`Job polling failed: ${error.message}`);
                }
            }

            throw new Error('Job processing timeout');
        }

        // Extract suggestions from hybrid API response
        function extractSuggestionsFromResponse(response) {
            // Handle hybrid controller wrapper format
            if (response.result) {
                const result = response.result;
                
                // Handle different suggestion formats
                if (result.suggestions) {
                    if (Array.isArray(result.suggestions)) {
                        return result.suggestions;
                    } else if (result.suggestions.suggestions) {
                        return result.suggestions.suggestions;
                    } else if (result.suggestions.raw) {
                        try {
                            const parsed = JSON.parse(result.suggestions.raw);
                            return parsed.suggestions || [];
                        } catch (e) {
                            console.warn('Failed to parse raw suggestions:', e);
                            return [];
                        }
                    }
                }

                // Handle optimize_selection with basic/enhanced suggestions
                if (result.basic_suggestions && result.basic_suggestions.suggestions) {
                    return result.basic_suggestions.suggestions;
                }
                
                return [];
            }

            // Handle direct suggestion format (fallback)
            if (response.suggestions) {
                return Array.isArray(response.suggestions) ? response.suggestions : [];
            }

            // Handle raw format (fallback)
            if (response.raw) {
                try {
                    const parsed = JSON.parse(response.raw);
                    return parsed.suggestions || [];
                } catch (e) {
                    console.warn('Failed to parse raw response:', e);
                    return [];
                }
            }

            console.warn('No suggestions found in response:', response);
            return [];
        }

        // Simple therapeutic area detection
        function detectTherapeuticArea(text) {
            const textLower = text.toLowerCase();
            
            if (textLower.includes('oncology') || textLower.includes('cancer') || textLower.includes('tumor')) {
                return 'oncology';
            } else if (textLower.includes('cardio') || textLower.includes('heart')) {
                return 'cardiology';
            } else if (textLower.includes('neuro') || textLower.includes('brain')) {
                return 'neurology';
            }
            
            return 'general_medicine';
        }

        // ===== TA ON-DEMAND ENHANCEMENT =====
        
        // Enhanced suggestion with TA-aware rewriting
        async function enhanceSuggestionWithTA(issue) {
            if (!issue.text || !issue.suggestion) return issue;

            try {
                const response = await fetch(`${API_BASE_URL}/api/generate-rewrite-ta`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        text: issue.text,
                        ta: detectTherapeuticArea(issue.text),
                        context: 'protocol_enhancement',
                        suggestion_id: issue.id
                    })
                });

                if (response.status === 202) {
                    // TA enhancement queued
                    const queuedResult = await response.json();
                    issue.ta_enhancement = {
                        status: 'queued',
                        message: queuedResult.message,
                        suggestion_id: queuedResult.suggestion_id
                    };
                    return issue;
                }

                if (!response.ok) {
                    console.warn('TA enhancement failed, using original suggestion');
                    return issue;
                }

                const taResult = await response.json();
                
                // Enhance the issue with TA-aware improvements
                issue.suggestion = taResult.improved || issue.suggestion;
                issue.rationale = taResult.rationale || issue.rationale;
                issue.regulatory_source = taResult.sources ? taResult.sources.join(', ') : issue.regulatory_source;
                issue.ta_enhanced = true;

                return issue;

            } catch (error) {
                console.warn('TA enhancement error:', error);
                return issue;
            }
        }

        // ===== SUGGESTION FORMAT HELPERS =====
        
        // Get original text from different suggestion formats
        function getOriginalText(issue) {
            return issue.text || issue.original || issue.originalText || '';
        }

        // Get suggestion text from different formats
        function getSuggestionText(issue) {
            return issue.suggestion || issue.improved || issue.suggestedText || 'No suggestion available';
        }

        // Get rationale text from different formats
        function getRationaleText(issue) {
            return issue.rationale || issue.reason || issue.complianceRationale || '';
        }

        // Get regulatory source from different formats
        function getRegulatorySource(issue) {
            return issue.regulatory_source || issue.fdaReference || issue.emaReference || '';
        }

        // Normalize issue format for display
        function normalizeIssue(rawIssue) {
            return {
                id: rawIssue.id || `issue_${Date.now()}_${Math.random()}`,
                type: rawIssue.type || 'medical_terminology',
                severity: rawIssue.severity || 'medium',
                text: getOriginalText(rawIssue),
                suggestion: getSuggestionText(rawIssue),
                rationale: getRationaleText(rawIssue),
                regulatory_source: getRegulatorySource(rawIssue),
                confidence: rawIssue.confidence || 0.9,
                ta_enhanced: rawIssue.ta_enhanced || false,
                position: rawIssue.position || rawIssue.range || { start: 0, end: 0 }
            };
        }

        /* --- Result handler & UI helpers --- */

        function handleAnalyzeResult(wrapper) {
            // normalize wrapper: { request_id, model_path, result }
            const result = wrapper?.result || wrapper;
            if (!result) {
                showToast("No result returned from server.");
                return;
            }
            if (result.status === "queued") {
                showToast("Analysis queued (job id: " + (result.job_id || result.jobId) + ")");
                return;
            }
            const suggestions = result.suggestions || result;
            renderSuggestionCards(suggestions, wrapper.request_id || result.request_id);
        }

        function showToast(message, ms = 5000) {
            // Implement simple toast if you have one, or alert as fallback
            const t = document.getElementById('ilanaToast');
            if (t) {
                t.innerText = message;
                t.style.display = 'block';
                setTimeout(() => t.style.display = 'none', ms);
            } else {
                console.log("TOAST:", message);
                // Fallback to status update for now
                updateStatus(message, 'ready');
            }
        }

        function openJobProgressPanel(jobId) {
            // Implement showing a side panel or progress modal and call connectToJobStream(jobId)
            console.log("Opening job progress panel for job:", jobId);
            showJobQueuedMessage(jobId, 'job_' + Date.now());
        }

        async function callOptimizeDocumentAsync(payload) {
            // payload = { text, ta, user_id_hash }
            const apiBase = window.__ILANA_API_BASE__ || API_BASE_URL;
            // Prefer canonical endpoint:
            const analyzeUrl = `${apiBase}/api/analyze`;
            try {
                const resp = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: payload.text, mode: 'document_truncated', ta: payload.ta })
                });
                if (!resp.ok) {
                    // fallback to optimize-document-async for backward compatibility
                    const fallbackResp = await fetch(`${apiBase}/api/optimize-document-async`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(payload)
                    });
                    return await fallbackResp.json();
                }
                return await resp.json();
            } catch (err) {
                console.warn("callOptimizeDocumentAsync analyze fallback: ", err);
                // Try direct optimize-document-async call as last resort
                const fallback = await fetch(`${apiBase}/api/optimize-document-async`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                return await fallback.json();
            }
        }

        function renderSuggestionCards(suggestions, requestId) {
            // Use existing displayAnalysisResults function for backward compatibility
            displayAnalysisResults(suggestions, { request_id: requestId });
        }
    </script>
</body>
</html>