<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ilana</title>
    <script type="text/javascript" src="https://appsforoffice.microsoft.com/lib/1.1/hosted/office.js"></script>
    
    <script>
        // Dev override for API base URL - replace with your ngrok or staging URL during dev
        window.__ILANA_API_BASE__ = "http://127.0.0.1:8000";
    </script>
    <style>
        /* Professional taskpane design system */
        
        :root {
            --primary-green: #11a683;
            --primary-green-hover: #15c894;
            --primary-red: #ea1537;
            --primary-red-hover: #f23452;
            --primary-blue: #3b82f6;
            --primary-orange: #f59e0b;
            --text-gray: #8189a9;
            --text-dark: #0e101a;
            --background-light: #f0f2fc;
            --border-light: #e4e6f2;
            --surface-white: #ffffff;
            --surface-hover: #f8fafc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--surface-white);
            color: var(--text-dark);
            font-size: 14px;
            line-height: 1.4;
            height: 100vh;
            overflow: hidden;
        }

        /* Main sidebar wrapper */
        .sidebar-wrapper {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .wrapper {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* Header wrapper */
        .header-wrapper {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the button */
            margin-bottom: 8px;
        }

        .lens-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-dark);
            display: none; /* Hide this element */
        }

        .header-btn {
            background: var(--primary-green);
            color: var(--surface-white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .header-btn:hover {
            background: var(--primary-green-hover);
        }

        .header-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Navigation container */
        .navigation-container {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-light);
            flex-shrink: 0;
            background: var(--background-light);
        }

        .all-alerts-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .all-alerts-stats {
            color: var(--text-gray);
            font-size: 13px;
        }

        .counter-wrapper {
            display: flex;
            gap: 16px;
        }

        .counter-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .counter-number {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            min-width: 18px;
            text-align: center;
        }

        .counter-number.low {
            background: var(--text-gray);
        }

        .counter-number.medium {
            background: var(--primary-orange);
        }

        /* Scroll content */
        .scroll-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .card-wrapper {
            border-bottom: 1px solid var(--border-light);
        }

        .card-wrapper:last-child {
            border-bottom: none;
        }

        /* Full card structure */
        .full-card {
            padding: 20px;
            background: var(--surface-white);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .full-card:hover {
            background: var(--surface-hover);
        }

        .full-card.maximized {
            background: var(--background-light);
        }

        .card-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: var(--surface-white);
        }

        .card-logo.critical {
            background: var(--primary-red);
        }

        .card-logo.high {
            background: var(--primary-red);
        }

        .card-logo.medium {
            background: var(--primary-orange);
        }

        .card-logo.low {
            background: var(--text-gray);
        }

        /* Report list - suggestion items */
        .report-list {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .item-original {
            position: relative;
            color: var(--primary-red);
            text-decoration: line-through;
            margin-right: 8px;
            font-weight: 500;
        }

        .item-original:after {
            content: 'â†’';
            color: var(--text-gray);
            margin-left: 8px;
            text-decoration: none;
        }

        .item-insert {
            background: var(--primary-green);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-insert:hover {
            background: var(--primary-green-hover);
        }

        .item-remove {
            background: var(--primary-red);
            color: var(--surface-white);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .item-remove:hover {
            background: var(--primary-red-hover);
        }

        /* Full sentence background */
        .full-sentence-background {
            background: var(--background-light);
            padding: 12px;
            border-radius: 4px;
            margin: 12px 0;
            font-style: italic;
            line-height: 1.4;
            color: var(--text-dark);
        }

        .full-sentence-insert {
            color: var(--primary-green);
            font-weight: 600;
        }

        .full-sentence-delete {
            color: var(--primary-red);
            text-decoration: line-through;
            font-weight: 600;
        }

        /* Card footer */
        .card-footer {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .card-footer-btn {
            background: transparent;
            border: 1px solid var(--border-light);
            color: var(--text-dark);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-footer-btn:hover {
            background: var(--surface-hover);
            border-color: var(--text-gray);
        }

        .card-footer-btn.primary {
            background: var(--primary-green);
            border-color: var(--primary-green);
            color: var(--surface-white);
        }

        .card-footer-btn.primary:hover {
            background: var(--primary-green-hover);
            border-color: var(--primary-green-hover);
        }

        /* Minimized state */
        .minimized .report-list {
            margin-bottom: 0;
        }

        .minimized .full-sentence-background,
        .minimized .card-footer {
            display: none;
        }

        /* Status indicators */
        .status-indicator {
            padding: 12px 20px;
            text-align: center;
            font-size: 13px;
            background: var(--background-light);
            color: var(--text-gray);
            border-bottom: 1px solid var(--border-light);
            display: none; /* Hide status indicator */
        }

        .status-indicator.analyzing {
            color: var(--primary-blue);
        }

        .status-indicator.complete {
            background: var(--primary-green);
            color: var(--surface-white);
        }

        .status-indicator.error {
            background: var(--primary-red);
            color: var(--surface-white);
        }

        /* Loading animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* Empty state */
        .empty-state {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-gray);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: var(--primary-green);
        }

        .empty-state-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-dark);
        }

        .empty-state-subtitle {
            font-size: 13px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <!-- Professional sidebar wrapper -->
    <div class="sidebar-wrapper">
        <div class="wrapper">
            <!-- Header wrapper -->
            <div class="header-wrapper">
                <div class="header">
                    <div class="lens-title">Ilana</div>
                    <button id="analyzeButton" class="header-btn" onclick="analyzeProtocol()">
                        Analyze
                    </button>
                </div>
            </div>

            <!-- Status indicator -->
            <div id="statusIndicator" class="status-indicator hidden">
                <span id="statusText"></span>
            </div>

            <!-- Navigation container -->
            <div id="navigationContainer" class="navigation-container hidden">
                <div class="all-alerts-container">
                    <div class="all-alerts-stats">
                        <span id="totalIssues">0 issues found</span>
                    </div>
                    <div class="counter-wrapper">
                        <div class="counter-content">
                            <span class="counter-number" id="criticalCount">0</span>
                            <span>Critical</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number medium" id="mediumCount">0</span>
                            <span>Medium</span>
                        </div>
                        <div class="counter-content">
                            <span class="counter-number low" id="lowCount">0</span>
                            <span>Low</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Scroll content -->
            <div class="scroll-content">
                <div id="cardsList"></div>
                
                <!-- Empty state -->
                <div id="emptyState" class="empty-state">
                    <div class="empty-state-icon">âœ“</div>
                    <div class="empty-state-title">Ready to analyze</div>
                    <div class="empty-state-subtitle">Click "Analyze" to check your protocol for compliance, clarity, and feasibility issues.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Pharmaceutical Protocol Analyzer - Professional Interface
        const API_BASE_URL = window.__ILANA_API_BASE__ || 'https://ilanalabs-add-in.onrender.com';
        let currentIssues = [];
        let maximizedCard = null;

        // Initialize Office.js
        Office.onReady(() => {
            console.log('ðŸš€ Ilana Protocol Intelligence loaded');
            updateStatus('Ready to analyze pharmaceutical protocols', 'complete');
        });

        // Main analysis function - now with hybrid API support
        async function analyzeProtocol() {
            const analyzeButton = document.getElementById('analyzeButton');

            try {
                // Update UI to analyzing state
                analyzeButton.disabled = true;
                analyzeButton.textContent = 'Analyzing...';
                updateStatus('Extracting protocol text<span class="loading-dots"></span>', 'analyzing');
                hideEmptyState();

                // Extract text from Word document
                await Word.run(async (context) => {
                    const body = context.document.body;
                    context.load(body, 'text');
                    await context.sync();

                    const documentText = body.text;
                    
                    if (documentText.length < 10) {
                        throw new Error('Document appears to be empty or too short for analysis');
                    }

                    updateStatus(`Analyzing ${documentText.length.toLocaleString()} characters with Hybrid AI<span class="loading-dots"></span>`, 'analyzing');

                    // Use hybrid API for analysis
                    const analysisResult = await performHybridAnalysis(documentText);
                    
                    // Handle both immediate and queued responses
                    if (analysisResult.status === 'queued' && analysisResult.job_id) {
                        await handleQueuedJob(analysisResult);
                    } else {
                        const issues = extractSuggestionsFromResponse(analysisResult);
                        displayAnalysisResults(issues, analysisResult.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                    }
                });

            } catch (error) {
                console.error('Analysis error:', error);
                updateStatus(`Analysis failed: ${error.message}`, 'error');
                showEmptyState();
            } finally {
                // Reset button
                analyzeButton.disabled = false;
                analyzeButton.textContent = 'Analyze';
            }
        }

        // Display analysis results
        function displayAnalysisResults(issues, metadata) {
            // Normalize issues to handle different formats
            const normalizedIssues = issues.map(issue => normalizeIssue(issue));
            currentIssues = normalizedIssues;
            
            if (normalizedIssues.length === 0) {
                showEmptyState();
                hideNavigation();
                return;
            }

            // Update navigation
            updateNavigation(normalizedIssues);
            showNavigation();
            
            // Display cards
            displayCards(normalizedIssues);
        }

        // Update navigation counters
        function updateNavigation(issues) {
            const counts = { critical: 0, high: 0, medium: 0, low: 0 };
            
            issues.forEach(issue => {
                if (counts.hasOwnProperty(issue.severity)) {
                    counts[issue.severity]++;
                }
            });

            document.getElementById('totalIssues').textContent = `${issues.length} issues found`;
            document.getElementById('criticalCount').textContent = counts.critical + counts.high;
            document.getElementById('mediumCount').textContent = counts.medium;
            document.getElementById('lowCount').textContent = counts.low;
        }

        // Display cards in Grammarly style
        function displayCards(issues) {
            const cardsList = document.getElementById('cardsList');
            
            cardsList.innerHTML = issues.map((issue, index) => `
                <div class="card-wrapper">
                    <div class="full-card ${index === maximizedCard ? 'maximized' : 'minimized'}" onclick="toggleCard(${index})">
                        <div class="card-logo ${issue.severity}">
                            ${getSeverityIcon(issue.severity)}
                        </div>
                        
                        <div class="report-list">
                            ${getOriginalText(issue) ? `<span class="item-original">${getOriginalText(issue).substring(0, 100)}${getOriginalText(issue).length > 100 ? '...' : ''}</span>` : ''}
                            <span class="item-insert" onclick="highlightAndScrollToIssue('${issue.id}', event)">${getSuggestionText(issue).substring(0, 100)}${getSuggestionText(issue).length > 100 ? '...' : ''}</span>
                        </div>
                        
                        ${index === maximizedCard ? `
                            <div class="full-sentence-background">
                                <strong>Pharmaceutical Recommendation:</strong><br>
                                ${getSuggestionText(issue)}
                                ${getRationaleText(issue) ? `<br><br><strong>Clinical Impact:</strong> ${getRationaleText(issue)}` : ''}
                                ${getRegulatorySource(issue) ? `<br><br>ðŸ“‹ <strong>Regulatory Reference:</strong> ${getRegulatorySource(issue)}` : ''}
                                ${issue.ta_enhanced ? `<br><br>ðŸ”¬ <strong>TA Enhanced</strong>` : ''}
                            </div>
                            
                            <div class="card-footer">
                                <button class="card-footer-btn primary" onclick="highlightAndScrollToIssue('${issue.id}', event)">
                                    Locate in Document
                                </button>
                                <button class="card-footer-btn" onclick="dismissIssue(${index}, event)">
                                    Dismiss
                                </button>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        // Toggle card maximized/minimized state
        function toggleCard(index) {
            maximizedCard = maximizedCard === index ? null : index;
            displayCards(currentIssues);
        }

        // Dismiss issue
        function dismissIssue(index, event) {
            event.stopPropagation();
            currentIssues.splice(index, 1);
            if (maximizedCard === index) {
                maximizedCard = null;
            } else if (maximizedCard > index) {
                maximizedCard--;
            }
            displayAnalysisResults(currentIssues, null);
        }

        // Get severity icon
        function getSeverityIcon(severity) {
            switch (severity) {
                case 'critical': return '!';
                case 'high': return '!';
                case 'medium': return 'â–³';
                case 'low': return 'â—‹';
                default: return '?';
            }
        }

        // Highlight and scroll to issue in document
        async function highlightAndScrollToIssue(issueId, event) {
            if (event) event.stopPropagation();
            
            try {
                await Word.run(async (context) => {
                    const issue = currentIssues.find(i => i.id === issueId);
                    if (!issue || !issue.text) return;

                    // Clear existing highlights first
                    const allRanges = context.document.body.search("*", {matchWildcards: true});
                    context.load(allRanges, 'items');
                    await context.sync();
                    
                    allRanges.items.forEach(range => {
                        range.font.highlightColor = null;
                    });
                    
                    // Search for the issue text
                    let searchText = issue.text.substring(0, 100).trim();
                    let searchResults = context.document.body.search(searchText);
                    context.load(searchResults, 'items');
                    await context.sync();

                    // If not found, try shorter text
                    if (searchResults.items.length === 0 && searchText.length > 30) {
                        searchText = issue.text.substring(0, 30).trim();
                        searchResults = context.document.body.search(searchText);
                        context.load(searchResults, 'items');
                        await context.sync();
                    }

                    if (searchResults.items.length > 0) {
                        const firstResult = searchResults.items[0];
                        
                        // Highlight with severity color
                        firstResult.font.highlightColor = getSeverityColor(issue.severity);
                        
                        // Select and scroll to the text
                        firstResult.select("Select");
                        
                        console.log(`âœ… Highlighted and scrolled to ${issue.severity} issue`);
                    } else {
                        console.warn(`âš ï¸ Could not find text in document: ${searchText}`);
                        updateStatus(`Could not locate text in document`, 'error');
                        setTimeout(() => updateStatus('Analysis complete', 'complete'), 3000);
                    }

                    await context.sync();
                });
            } catch (error) {
                console.error('Highlighting error:', error);
                updateStatus(`Error highlighting text: ${error.message}`, 'error');
            }
        }

        // Get color for severity
        function getSeverityColor(severity) {
            switch (severity) {
                case 'critical': return '#ea1537';
                case 'high': return '#ea1537';
                case 'medium': return '#f59e0b';
                case 'low': return '#8189a9';
                default: return '#11a683';
            }
        }

        // Update status indicator
        function updateStatus(message, type) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            statusText.innerHTML = message;
            statusIndicator.className = `status-indicator ${type}`;
            statusIndicator.classList.remove('hidden');
        }

        // Show/hide navigation
        function showNavigation() {
            document.getElementById('navigationContainer').classList.remove('hidden');
        }

        function hideNavigation() {
            document.getElementById('navigationContainer').classList.add('hidden');
        }

        // Show/hide empty state
        function showEmptyState() {
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('cardsList').innerHTML = '';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').classList.add('hidden');
        }

        // ===== HYBRID API FUNCTIONS =====
        
        // Hybrid analysis with selection-first approach
        async function performHybridAnalysis(documentText) {
            // For large documents, use async document processing
            if (documentText.length > 10000) {
                return await createAsyncDocumentJob(documentText);
            }
            
            // For smaller documents, use direct analysis
            const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    text: documentText,
                    mode: 'document_chunked',
                    ta: detectTherapeuticArea(documentText)
                })
            });

            if (!response.ok) {
                throw new Error(`Hybrid analysis failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // Create async document job for large documents
        async function createAsyncDocumentJob(documentText) {
            const response = await fetch(`${API_BASE_URL}/api/optimize-document-async`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify({
                    text: documentText,
                    ta: detectTherapeuticArea(documentText),
                    options: {
                        analysis_depth: "detailed",
                        provide_examples: true,
                        include_recommendations: true
                    }
                })
            });

            if (!response.ok) {
                throw new Error(`Job creation failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        }

        // Handle queued job with SSE streaming
        async function handleQueuedJob(jobResult) {
            const jobId = jobResult.job_id;
            updateStatus(`Job queued: ${jobId}<span class="loading-dots"></span>`, 'analyzing');

            try {
                // Use EventSource for SSE streaming
                const eventSource = new EventSource(`${API_BASE_URL}/api/stream-job/${jobId}/events`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    
                    if (data.event_type === 'progress') {
                        updateStatus(`Processing: ${data.message}<span class="loading-dots"></span>`, 'analyzing');
                    } else if (data.event_type === 'complete') {
                        eventSource.close();
                        const issues = extractSuggestionsFromResponse(data);
                        displayAnalysisResults(issues, data.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                    } else if (data.event_type === 'error') {
                        eventSource.close();
                        throw new Error(data.message);
                    }
                };

                eventSource.onerror = function() {
                    eventSource.close();
                    // Fallback to polling
                    pollJobStatus(jobId);
                };

            } catch (error) {
                console.warn('SSE failed, falling back to polling:', error);
                await pollJobStatus(jobId);
            }
        }

        // Fallback polling for job status
        async function pollJobStatus(jobId) {
            const maxAttempts = 30;
            let attempts = 0;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/job-status/${jobId}`);
                    const jobStatus = await response.json();

                    if (jobStatus.status === 'completed') {
                        const issues = extractSuggestionsFromResponse(jobStatus.result);
                        displayAnalysisResults(issues, jobStatus.metadata || {});
                        updateStatus(`Analysis complete: ${issues.length} issues found`, 'complete');
                        return;
                    } else if (jobStatus.status === 'failed') {
                        throw new Error(jobStatus.error || 'Job processing failed');
                    }

                    updateStatus(`Processing${'.'.repeat((attempts % 3) + 1)}`, 'analyzing');
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    attempts++;

                } catch (error) {
                    throw new Error(`Job polling failed: ${error.message}`);
                }
            }

            throw new Error('Job processing timeout');
        }

        // Extract suggestions from hybrid API response
        function extractSuggestionsFromResponse(response) {
            // Handle hybrid controller wrapper format
            if (response.result) {
                const result = response.result;
                
                // Handle different suggestion formats
                if (result.suggestions) {
                    if (Array.isArray(result.suggestions)) {
                        return result.suggestions;
                    } else if (result.suggestions.suggestions) {
                        return result.suggestions.suggestions;
                    } else if (result.suggestions.raw) {
                        try {
                            const parsed = JSON.parse(result.suggestions.raw);
                            return parsed.suggestions || [];
                        } catch (e) {
                            console.warn('Failed to parse raw suggestions:', e);
                            return [];
                        }
                    }
                }

                // Handle optimize_selection with basic/enhanced suggestions
                if (result.basic_suggestions && result.basic_suggestions.suggestions) {
                    return result.basic_suggestions.suggestions;
                }
                
                return [];
            }

            // Handle direct suggestion format (fallback)
            if (response.suggestions) {
                return Array.isArray(response.suggestions) ? response.suggestions : [];
            }

            // Handle raw format (fallback)
            if (response.raw) {
                try {
                    const parsed = JSON.parse(response.raw);
                    return parsed.suggestions || [];
                } catch (e) {
                    console.warn('Failed to parse raw response:', e);
                    return [];
                }
            }

            console.warn('No suggestions found in response:', response);
            return [];
        }

        // Simple therapeutic area detection
        function detectTherapeuticArea(text) {
            const textLower = text.toLowerCase();
            
            if (textLower.includes('oncology') || textLower.includes('cancer') || textLower.includes('tumor')) {
                return 'oncology';
            } else if (textLower.includes('cardio') || textLower.includes('heart')) {
                return 'cardiology';
            } else if (textLower.includes('neuro') || textLower.includes('brain')) {
                return 'neurology';
            }
            
            return 'general_medicine';
        }

        // ===== TA ON-DEMAND ENHANCEMENT =====
        
        // Enhanced suggestion with TA-aware rewriting
        async function enhanceSuggestionWithTA(issue) {
            if (!issue.text || !issue.suggestion) return issue;

            try {
                const response = await fetch(`${API_BASE_URL}/api/generate-rewrite-ta`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        text: issue.text,
                        ta: detectTherapeuticArea(issue.text),
                        context: 'protocol_enhancement',
                        suggestion_id: issue.id
                    })
                });

                if (response.status === 202) {
                    // TA enhancement queued
                    const queuedResult = await response.json();
                    issue.ta_enhancement = {
                        status: 'queued',
                        message: queuedResult.message,
                        suggestion_id: queuedResult.suggestion_id
                    };
                    return issue;
                }

                if (!response.ok) {
                    console.warn('TA enhancement failed, using original suggestion');
                    return issue;
                }

                const taResult = await response.json();
                
                // Enhance the issue with TA-aware improvements
                issue.suggestion = taResult.improved || issue.suggestion;
                issue.rationale = taResult.rationale || issue.rationale;
                issue.regulatory_source = taResult.sources ? taResult.sources.join(', ') : issue.regulatory_source;
                issue.ta_enhanced = true;

                return issue;

            } catch (error) {
                console.warn('TA enhancement error:', error);
                return issue;
            }
        }

        // ===== SUGGESTION FORMAT HELPERS =====
        
        // Get original text from different suggestion formats
        function getOriginalText(issue) {
            return issue.text || issue.original || issue.originalText || '';
        }

        // Get suggestion text from different formats
        function getSuggestionText(issue) {
            return issue.suggestion || issue.improved || issue.suggestedText || 'No suggestion available';
        }

        // Get rationale text from different formats
        function getRationaleText(issue) {
            return issue.rationale || issue.reason || issue.complianceRationale || '';
        }

        // Get regulatory source from different formats
        function getRegulatorySource(issue) {
            return issue.regulatory_source || issue.fdaReference || issue.emaReference || '';
        }

        // Normalize issue format for display
        function normalizeIssue(rawIssue) {
            return {
                id: rawIssue.id || `issue_${Date.now()}_${Math.random()}`,
                type: rawIssue.type || 'medical_terminology',
                severity: rawIssue.severity || 'medium',
                text: getOriginalText(rawIssue),
                suggestion: getSuggestionText(rawIssue),
                rationale: getRationaleText(rawIssue),
                regulatory_source: getRegulatorySource(rawIssue),
                confidence: rawIssue.confidence || 0.9,
                ta_enhanced: rawIssue.ta_enhanced || false,
                position: rawIssue.position || rawIssue.range || { start: 0, end: 0 }
            };
        }
    </script>
</body>
</html>