<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ilana Word API Integration Test</title>
    
    <!-- Office UI Fabric -->
    <link rel="stylesheet" href="https://static2.sharepointonline.com/files/fabric/office-ui-fabric-core/1.0.0/css/fabric.min.css">
    
    <!-- Office.js -->
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
        }
        .test-title {
            color: #0078d4;
            border-bottom: 2px solid #0078d4;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .test-controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .test-btn {
            background: #0078d4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .test-btn:hover {
            background: #106ebe;
        }
        .test-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .test-output {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-success { background: #107c10; }
        .status-error { background: #d13438; }
        .status-pending { background: #ff8c00; }
        .status-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .mock-warning {
            background: #fff4e6;
            border: 1px solid #ff8c00;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            color: #8a4100;
        }
    </style>
</head>

<body>
    <div class="test-container">
        <h1>üìÑ Ilana Word API Integration Test</h1>
        <p>This page tests the integration between Ilana and Microsoft Word Office.js APIs.</p>

        <div class="mock-warning">
            <strong>‚ö†Ô∏è Note:</strong> This is a standalone test page. In production, these tests would run within a Word add-in context.
        </div>

        <!-- Office.js Initialization -->
        <div class="test-section">
            <h2 class="test-title">üöÄ Office.js Initialization</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testOfficeInitialization()">Test Office.js</button>
                <button class="test-btn" onclick="testWordAvailability()">Test Word APIs</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="office-status"></span>
                <span id="office-status-text">Not tested</span>
            </div>
            <div id="office-output" class="test-output">Office.js initialization status will appear here...</div>
        </div>

        <!-- Document Access -->
        <div class="test-section">
            <h2 class="test-title">üìñ Document Access</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testDocumentAccess()" id="doc-access-btn" disabled>Get Document Content</button>
                <button class="test-btn" onclick="testDocumentSelection()" id="doc-selection-btn" disabled>Get Selected Text</button>
                <button class="test-btn" onclick="testDocumentProperties()" id="doc-props-btn" disabled>Get Document Properties</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="document-status"></span>
                <span id="document-status-text">Office.js required</span>
            </div>
            <div id="document-output" class="test-output">Document access results will appear here...</div>
        </div>

        <!-- Text Insertion -->
        <div class="test-section">
            <h2 class="test-title">‚úèÔ∏è Text Insertion & Modification</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testTextInsertion()" id="text-insert-btn" disabled>Insert Test Text</button>
                <button class="test-btn" onclick="testSuggestionInsertion()" id="suggestion-insert-btn" disabled>Insert Suggestion</button>
                <button class="test-btn" onclick="testTextReplacement()" id="text-replace-btn" disabled>Replace Selected Text</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="insertion-status"></span>
                <span id="insertion-status-text">Office.js required</span>
            </div>
            <div id="insertion-output" class="test-output">Text insertion results will appear here...</div>
        </div>

        <!-- Ilana Integration -->
        <div class="test-section">
            <h2 class="test-title">üß† Ilana API Integration</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testAnalyzeDocument()" id="analyze-btn">Analyze Document</button>
                <button class="test-btn" onclick="testApplySuggestion()" id="apply-suggestion-btn" disabled>Apply Test Suggestion</button>
                <button class="test-btn" onclick="testFullWorkflow()" id="full-workflow-btn" disabled>Full Workflow Test</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="ilana-status"></span>
                <span id="ilana-status-text">Ready to test</span>
            </div>
            <div id="ilana-output" class="test-output">Ilana API integration results will appear here...</div>
        </div>

        <!-- Error Handling -->
        <div class="test-section">
            <h2 class="test-title">üõ†Ô∏è Error Handling & Edge Cases</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testErrorHandling()">Test Error Scenarios</button>
                <button class="test-btn" onclick="testPermissions()">Test Permissions</button>
                <button class="test-btn" onclick="testLargeDocument()">Test Large Document</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="error-status"></span>
                <span id="error-status-text">Not tested</span>
            </div>
            <div id="error-output" class="test-output">Error handling test results will appear here...</div>
        </div>

        <!-- Performance Testing -->
        <div class="test-section">
            <h2 class="test-title">‚ö° Performance Testing</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testPerformance()">Run Performance Tests</button>
                <button class="test-btn" onclick="testConcurrentOperations()">Test Concurrent Operations</button>
            </div>
            <div class="status-row">
                <span class="status-indicator" id="performance-status"></span>
                <span id="performance-status-text">Not tested</span>
            </div>
            <div id="performance-output" class="test-output">Performance test results will appear here...</div>
        </div>
    </div>

    <script>
        // Test state
        let officeInitialized = false;
        let wordAvailable = false;
        const API_BASE_URL = 'http://localhost:8000';

        // Utility functions
        function updateStatus(statusId, textId, message, success = null) {
            const statusElement = document.getElementById(statusId);
            const textElement = document.getElementById(textId);
            
            if (success === true) {
                statusElement.className = 'status-indicator status-success';
            } else if (success === false) {
                statusElement.className = 'status-indicator status-error';
            } else {
                statusElement.className = 'status-indicator status-pending';
            }
            
            textElement.textContent = message;
        }

        function updateOutput(elementId, content, isError = false) {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const status = isError ? '‚ùå' : '‚úÖ';
            element.textContent = `[${timestamp}] ${status} ${content}`;
        }

        function appendOutput(elementId, content) {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            element.textContent += `\n[${timestamp}] ${content}`;
        }

        function enableButtons(buttonIds) {
            buttonIds.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }

        // Office.js Tests
        function testOfficeInitialization() {
            updateOutput('office-output', 'Testing Office.js initialization...');
            
            if (typeof Office !== 'undefined') {
                updateOutput('office-output', 'Office.js is loaded');
                updateStatus('office-status', 'office-status-text', 'Office.js Available', true);
                
                // Try to initialize Office
                Office.onReady((info) => {
                    appendOutput('office-output', `Office initialized: ${info.host} version ${info.version}`);
                    officeInitialized = true;
                    testWordAvailability();
                }).catch((error) => {
                    appendOutput('office-output', `Office initialization failed: ${error.message}`);
                    updateStatus('office-status', 'office-status-text', 'Initialization Failed', false);
                });
            } else {
                updateOutput('office-output', 'Office.js not available (expected in standalone test)', true);
                updateStatus('office-status', 'office-status-text', 'Office.js Not Available', false);
                
                // Mock the initialization for testing
                appendOutput('office-output', 'Running in mock mode for standalone testing...');
                officeInitialized = true;
                wordAvailable = true;
                updateStatus('office-status', 'office-status-text', 'Mock Mode Active', null);
                enableWordApiButtons();
            }
        }

        function testWordAvailability() {
            appendOutput('office-output', 'Testing Word API availability...');
            
            if (typeof Word !== 'undefined') {
                appendOutput('office-output', 'Word API is available');
                wordAvailable = true;
                enableWordApiButtons();
            } else {
                appendOutput('office-output', 'Word API not available (using mock for testing)');
                // Mock Word API for testing
                window.Word = {
                    run: async function(callback) {
                        const context = {
                            document: {
                                body: {
                                    insertText: function(text, location) {
                                        return { text: text, location: location };
                                    },
                                    getText: function() {
                                        return "Mock document content for testing purposes. This simulates a protocol document with visits, procedures, and endpoints.";
                                    }
                                },
                                getSelection: function() {
                                    return {
                                        getText: function() {
                                            return "Selected text mock";
                                        }
                                    };
                                }
                            },
                            sync: async function() {
                                return Promise.resolve();
                            }
                        };
                        await callback(context);
                    }
                };
                wordAvailable = true;
                enableWordApiButtons();
            }
        }

        function enableWordApiButtons() {
            updateStatus('document-status', 'document-status-text', 'Word APIs Ready', true);
            updateStatus('insertion-status', 'insertion-status-text', 'Text Operations Ready', true);
            
            enableButtons([
                'doc-access-btn', 'doc-selection-btn', 'doc-props-btn',
                'text-insert-btn', 'suggestion-insert-btn', 'text-replace-btn',
                'apply-suggestion-btn', 'full-workflow-btn'
            ]);
        }

        // Document Access Tests
        async function testDocumentAccess() {
            updateOutput('document-output', 'Testing document content access...');
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const text = body.getText();
                    await context.sync();
                    
                    const content = typeof text === 'string' ? text : text.value || "Mock document content";
                    appendOutput('document-output', `Document content (${content.length} chars): ${content.substring(0, 100)}...`);
                    updateStatus('document-status', 'document-status-text', 'Document Access Working', true);
                });
            } catch (error) {
                appendOutput('document-output', `Document access error: ${error.message}`);
                updateStatus('document-status', 'document-status-text', 'Document Access Failed', false);
            }
        }

        async function testDocumentSelection() {
            appendOutput('document-output', 'Testing selected text access...');
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const text = selection.getText();
                    await context.sync();
                    
                    const selectedText = typeof text === 'string' ? text : text.value || "Mock selected text";
                    appendOutput('document-output', `Selected text: "${selectedText}"`);
                });
            } catch (error) {
                appendOutput('document-output', `Selection access error: ${error.message}`);
            }
        }

        async function testDocumentProperties() {
            appendOutput('document-output', 'Testing document properties...');
            
            try {
                // Mock document properties for testing
                const properties = {
                    title: "Protocol Document - Phase II Study",
                    author: "Test User",
                    lastModified: new Date().toISOString(),
                    wordCount: 2500
                };
                
                appendOutput('document-output', `Document properties: ${JSON.stringify(properties, null, 2)}`);
            } catch (error) {
                appendOutput('document-output', `Properties access error: ${error.message}`);
            }
        }

        // Text Insertion Tests
        async function testTextInsertion() {
            updateOutput('insertion-output', 'Testing text insertion...');
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const testText = "\n\n[ILANA TEST] This text was inserted by the Ilana Word API integration test.";
                    body.insertText(testText, Word.InsertLocation?.end || 'End');
                    await context.sync();
                    
                    appendOutput('insertion-output', 'Test text inserted successfully');
                    updateStatus('insertion-status', 'insertion-status-text', 'Text Insertion Working', true);
                });
            } catch (error) {
                appendOutput('insertion-output', `Text insertion error: ${error.message}`);
                updateStatus('insertion-status', 'insertion-status-text', 'Text Insertion Failed', false);
            }
        }

        async function testSuggestionInsertion() {
            appendOutput('insertion-output', 'Testing suggestion insertion...');
            
            try {
                const suggestion = {
                    type: 'procedure_consolidation',
                    suggested_text: 'Consolidate vital signs across visits 1-3 to reduce participant burden',
                    confidence: 0.87
                };
                
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const suggestionText = `\n\n[ILANA SUGGESTION] ${suggestion.suggested_text} (Confidence: ${Math.round(suggestion.confidence * 100)}%)`;
                    body.insertText(suggestionText, Word.InsertLocation?.end || 'End');
                    await context.sync();
                    
                    appendOutput('insertion-output', 'Suggestion inserted successfully');
                });
            } catch (error) {
                appendOutput('insertion-output', `Suggestion insertion error: ${error.message}`);
            }
        }

        async function testTextReplacement() {
            appendOutput('insertion-output', 'Testing text replacement...');
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const replacementText = "[REPLACED BY ILANA] Optimized text based on TA-aware analysis";
                    selection.insertText?.(replacementText, Word.InsertLocation?.replace || 'Replace');
                    await context.sync();
                    
                    appendOutput('insertion-output', 'Text replacement completed');
                });
            } catch (error) {
                appendOutput('insertion-output', `Text replacement error: ${error.message}`);
            }
        }

        // Ilana Integration Tests
        async function testAnalyzeDocument() {
            updateOutput('ilana-output', 'Testing Ilana API integration...');
            
            try {
                // Get document content (mock for testing)
                const documentContent = "Phase II study of pembrolizumab in breast cancer patients. Visit 1: vital signs, ECG, laboratory tests. Visit 2: vital signs, ECG, laboratory tests. Primary endpoint: progression-free survival per RECIST v1.1.";
                
                appendOutput('ilana-output', 'Sending document to Ilana API...');
                
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: documentContent,
                        analysis_type: 'comprehensive'
                    })
                });
                
                const analysis = await response.json();
                
                appendOutput('ilana-output', `Analysis complete: TA=${analysis.therapeutic_area}, Score=${analysis.overall_score}, Suggestions=${analysis.suggestions.length}`);
                appendOutput('ilana-output', `Processing time: ${analysis.processing_time}s`);
                
                // Store suggestions for testing
                window.testSuggestions = analysis.suggestions;
                updateStatus('ilana-status', 'ilana-status-text', 'Ilana Integration Working', true);
                
            } catch (error) {
                appendOutput('ilana-output', `Ilana API error: ${error.message}`);
                updateStatus('ilana-status', 'ilana-status-text', 'Ilana Integration Failed', false);
            }
        }

        async function testApplySuggestion() {
            appendOutput('ilana-output', 'Testing suggestion application...');
            
            if (window.testSuggestions && window.testSuggestions.length > 0) {
                const suggestion = window.testSuggestions[0];
                
                try {
                    await Word.run(async (context) => {
                        const body = context.document.body;
                        const suggestionText = `\n\n[APPLIED SUGGESTION] ${suggestion.suggested_text}\nType: ${suggestion.type}\nConfidence: ${Math.round(suggestion.confidence * 100)}%\nEstimated Savings: $${suggestion.estimated_savings.cost_saved_usd}`;
                        body.insertText(suggestionText, Word.InsertLocation?.end || 'End');
                        await context.sync();
                        
                        appendOutput('ilana-output', 'Suggestion applied to document successfully');
                    });
                } catch (error) {
                    appendOutput('ilana-output', `Suggestion application error: ${error.message}`);
                }
            } else {
                appendOutput('ilana-output', 'No suggestions available - run document analysis first');
            }
        }

        async function testFullWorkflow() {
            appendOutput('ilana-output', 'Testing full Ilana workflow...');
            
            try {
                // Step 1: Get document content
                appendOutput('ilana-output', '1. Extracting document content...');
                await testDocumentAccess();
                
                // Step 2: Analyze with Ilana
                appendOutput('ilana-output', '2. Analyzing with Ilana API...');
                await testAnalyzeDocument();
                
                // Step 3: Apply first suggestion
                appendOutput('ilana-output', '3. Applying suggestion to document...');
                await testApplySuggestion();
                
                appendOutput('ilana-output', '‚úÖ Full workflow completed successfully!');
                
            } catch (error) {
                appendOutput('ilana-output', `Full workflow error: ${error.message}`);
            }
        }

        // Error Handling Tests
        async function testErrorHandling() {
            updateOutput('error-output', 'Testing error handling scenarios...');
            
            // Test API error
            try {
                appendOutput('error-output', 'Testing API error handling...');
                await fetch(`${API_BASE_URL}/api/invalid-endpoint`);
            } catch (error) {
                appendOutput('error-output', `API error handled: ${error.message}`);
            }
            
            // Test Word API error
            try {
                appendOutput('error-output', 'Testing Word API error handling...');
                await Word.run(async (context) => {
                    // Intentionally cause an error
                    context.document.invalidMethod?.();
                    await context.sync();
                });
            } catch (error) {
                appendOutput('error-output', `Word API error handled: ${error.message}`);
            }
            
            updateStatus('error-status', 'error-status-text', 'Error Handling Tested', true);
        }

        async function testPermissions() {
            appendOutput('error-output', 'Testing permission scenarios...');
            appendOutput('error-output', 'Permissions test: ReadWriteDocument access simulated');
        }

        async function testLargeDocument() {
            appendOutput('error-output', 'Testing large document handling...');
            
            // Generate realistic large protocol document (200,000+ characters like real pharma protocols)
            const protocolSections = [
                "PROTOCOL TITLE: A Randomized, Double-Blind, Placebo-Controlled, Phase III Study of [DRUG] versus Placebo in Patients with Advanced [INDICATION]",
                "1. BACKGROUND AND RATIONALE: The therapeutic area of [TA] has seen significant advances in recent years with the development of targeted therapies and immunotherapies. Current standard of care includes multiple treatment options, however, there remains a significant unmet medical need for patients who progress on or are intolerant to existing therapies.",
                "2. STUDY OBJECTIVES: Primary Objective: To evaluate the progression-free survival (PFS) per investigator assessment according to RECIST v1.1 criteria of [DRUG] compared to placebo in patients with advanced [INDICATION]. Secondary Objectives: To evaluate overall survival (OS), objective response rate (ORR), duration of response (DOR), disease control rate (DCR), time to response (TTR), and safety and tolerability.",
                "3. STUDY DESIGN: This is a multicenter, randomized, double-blind, placebo-controlled, Phase III study comparing [DRUG] with placebo in patients with advanced [INDICATION]. Approximately 600 patients will be randomized 2:1 to receive either [DRUG] or matching placebo.",
                "4. STUDY POPULATION: Inclusion Criteria: Adult patients (‚â•18 years) with histologically or cytologically confirmed advanced [INDICATION]; Measurable disease per RECIST v1.1 criteria; ECOG performance status 0-1; Adequate organ function; Life expectancy ‚â•12 weeks. Exclusion Criteria: Prior treatment with [DRUG CLASS]; Active brain metastases; Significant cardiovascular disease; Active autoimmune disease.",
                "5. TREATMENT PLAN: Subjects will be randomized 2:1 to receive either [DRUG] 400mg orally once daily or matching placebo orally once daily in 28-day cycles. Treatment will continue until disease progression, unacceptable toxicity, withdrawal of consent, or death. Dose modifications and interruptions are permitted for safety reasons.",
                "6. STUDY PROCEDURES: Screening Visit (Days -28 to -1): Obtain informed consent; Medical history and physical examination; Vital signs and weight; Laboratory assessments (hematology, chemistry, urinalysis); ECG and echocardiogram; Tumor assessment by CT/MRI; Pregnancy test (if applicable); Concomitant medications review.",
                "7. EFFICACY ASSESSMENTS: Tumor response will be assessed by CT or MRI according to RECIST v1.1 criteria. Imaging will be performed at baseline (within 28 days of randomization), every 8 weeks (¬±7 days) for the first 12 months, then every 12 weeks (¬±7 days) thereafter until disease progression. All scans will be reviewed by the investigator and centrally by an independent radiology review committee.",
                "8. SAFETY MONITORING: All adverse events (AEs) will be recorded from the time of informed consent through 30 days after the last dose of study drug. AEs will be graded according to NCI CTCAE v5.0. Serious adverse events (SAEs) must be reported within 24 hours. Laboratory assessments will be performed at baseline, Cycle 1 Day 15, then every cycle.",
                "9. STATISTICAL CONSIDERATIONS: The primary efficacy analysis will be performed on the intent-to-treat (ITT) population, defined as all randomized patients. A sample size of 600 patients provides 90% power to detect a hazard ratio of 0.67 for PFS, assuming a median PFS of 6 months in the placebo arm, with a two-sided alpha of 0.05.",
                "10. DATA MANAGEMENT: All study data will be recorded in electronic case report forms (eCRFs) using a validated clinical data management system. Data will be monitored for completeness, consistency, and accuracy. Database lock will occur after all data queries have been resolved and the database has been declared complete and accurate.",
                "11. REGULATORY CONSIDERATIONS: This study will be conducted in accordance with ICH Good Clinical Practice (GCP) guidelines, applicable regulatory requirements, and institutional policies. The protocol must be approved by institutional review boards/ethics committees before study initiation."
            ];
            
            // Expand each section with realistic pharmaceutical protocol detail
            let largeProtocol = "";
            for (let i = 0; i < protocolSections.length; i++) {
                const section = protocolSections[i];
                
                // Add detailed subsections for each main section
                let expandedSection = section + "\n\n";
                
                // Add realistic protocol details
                const detailTemplates = [
                    "This section provides comprehensive guidance on study procedures, regulatory compliance requirements, and operational considerations.",
                    "Detailed instructions for site staff include step-by-step procedures, timing requirements, and documentation standards.",
                    "Safety monitoring procedures must be followed according to sponsor requirements and regulatory guidelines.",
                    "All assessments must be performed within specified time windows as outlined in the study calendar.",
                    "Source documentation requirements include contemporaneous recording of all study-related activities.",
                    "Quality assurance measures ensure data integrity and regulatory compliance throughout the study.",
                    "Adverse event reporting procedures follow international guidelines for clinical trial safety reporting.",
                    "Protocol deviations must be documented and reported according to sponsor and regulatory requirements.",
                    "Training requirements include GCP certification and protocol-specific training for all site personnel.",
                    "Monitoring activities will be conducted according to a risk-based monitoring approach."
                ];
                
                // Add 20-30 realistic paragraphs per section
                for (let j = 0; j < 25; j++) {
                    const template = detailTemplates[j % detailTemplates.length];
                    expandedSection += `${i+1}.${j+1} ${template} Additional considerations include data quality requirements, source document verification, protocol compliance monitoring, adverse event management, concomitant medication tracking, and comprehensive documentation of all study-related activities. The study team must ensure adherence to Good Clinical Practice guidelines, regulatory requirements, institutional policies, and sponsor-specific procedures throughout the conduct of this clinical trial.\n\n`;
                }
                
                largeProtocol += expandedSection;
            }
            
            // Add appendices (common in real protocols)
            const appendices = [
                "APPENDIX A: Study Calendar and Visit Schedule",
                "APPENDIX B: Inclusion and Exclusion Criteria Details", 
                "APPENDIX C: Concomitant Medication Guidelines",
                "APPENDIX D: Laboratory Normal Values and Procedures",
                "APPENDIX E: Adverse Event Reporting Procedures",
                "APPENDIX F: Emergency Contact Information",
                "APPENDIX G: Protocol Amendment History",
                "APPENDIX H: Informed Consent Form Template"
            ];
            
            for (let appendix of appendices) {
                largeProtocol += appendix + "\n\n";
                // Add detailed content for each appendix
                for (let k = 0; k < 50; k++) {
                    largeProtocol += `Detailed information for ${appendix.toLowerCase()} including comprehensive procedures, requirements, contact information, forms, templates, and guidelines that are essential for proper study conduct and regulatory compliance. This appendix provides specific instructions and reference materials for study site personnel.\n\n`;
                }
            }
            
            const documentSize = largeProtocol.length;
            appendOutput('error-output', `Generated realistic pharmaceutical protocol: ${documentSize.toLocaleString()} characters`);
            
            // Ensure we reach realistic enterprise protocol size (200K+ characters)
            if (documentSize < 200000) {
                const additionalContent = "Additional protocol sections including detailed standard operating procedures, case report form completion guidelines, data management procedures, quality assurance requirements, regulatory compliance checklists, site management instructions, and comprehensive appendices with forms, templates, and reference materials. ".repeat(500);
                largeProtocol += additionalContent;
            }
            
            const finalSize = largeProtocol.length;
            appendOutput('error-output', `Final protocol size: ${finalSize.toLocaleString()} characters (matches real pharma protocol sizes)`);
            
            // Test API performance with enterprise-scale document
            try {
                appendOutput('error-output', 'Testing Ilana API with enterprise-scale protocol...');
                const startTime = performance.now();
                
                const response = await fetch(`${API_BASE_URL}/api/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: largeProtocol,
                        analysis_type: 'enterprise_protocol_test'
                    })
                });
                
                const endTime = performance.now();
                const processingTime = (endTime - startTime) / 1000;
                
                if (response.ok) {
                    const analysisData = await response.json();
                    appendOutput('error-output', `‚úÖ Enterprise protocol analysis completed:`);
                    appendOutput('error-output', `   üìÑ Size: ${finalSize.toLocaleString()} characters`);
                    appendOutput('error-output', `   ‚è±Ô∏è Processing time: ${processingTime.toFixed(2)} seconds`);
                    appendOutput('error-output', `   üéØ TA detected: ${analysisData.therapeutic_area}`);
                    appendOutput('error-output', `   üí° Suggestions: ${analysisData.suggestions.length}`);
                    appendOutput('error-output', `   üìä Overall score: ${analysisData.overall_score}`);
                    appendOutput('error-output', `   üöÄ Performance: ${Math.round(finalSize/processingTime).toLocaleString()} chars/second`);
                    
                    // Enterprise performance benchmarks
                    if (processingTime < 30) {
                        appendOutput('error-output', 'üü¢ EXCELLENT: <30s for 200K+ character enterprise protocol');
                    } else if (processingTime < 60) {
                        appendOutput('error-output', 'üü° ACCEPTABLE: 30-60s for large enterprise protocol');
                    } else if (processingTime < 120) {
                        appendOutput('error-output', 'üü† NEEDS OPTIMIZATION: 1-2 minutes for enterprise protocol');
                    } else {
                        appendOutput('error-output', 'üî¥ PERFORMANCE ISSUE: >2 minutes for enterprise protocol');
                    }
                    
                    // Enterprise deployment considerations
                    appendOutput('error-output', 'üìã Enterprise Deployment Insights:');
                    if (analysisData.suggestions.length > 10) {
                        appendOutput('error-output', `   ‚úÖ Good coverage: ${analysisData.suggestions.length} optimization opportunities found`);
                    } else {
                        appendOutput('error-output', `   ‚ö†Ô∏è May need tuning: Only ${analysisData.suggestions.length} suggestions for large protocol`);
                    }
                    
                } else {
                    appendOutput('error-output', `‚ùå Enterprise protocol analysis failed: ${response.status} ${response.statusText}`);
                    if (response.status === 413) {
                        appendOutput('error-output', '   üí° SOLUTION: Implement document chunking for 200K+ protocols');
                    } else if (response.status === 504) {
                        appendOutput('error-output', '   üí° SOLUTION: Add async processing with progress tracking');
                    } else if (response.status === 500) {
                        appendOutput('error-output', '   üí° SOLUTION: Optimize memory usage for large document processing');
                    }
                }
                
            } catch (error) {
                appendOutput('error-output', `‚ùå Enterprise protocol processing error: ${error.message}`);
                if (error.message.includes('NetworkError') || error.message.includes('fetch')) {
                    appendOutput('error-output', '   üí° SOLUTION: Implement chunked upload for very large protocols');
                } else if (error.message.includes('timeout')) {
                    appendOutput('error-output', '   üí° SOLUTION: Add progress indicators and background processing');
                }
            }
            
            // Test Word API integration with large documents
            appendOutput('error-output', 'Testing Word API with large protocol...');
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    
                    // Test reading large document
                    const documentText = body.getText();
                    await context.sync();
                    
                    appendOutput('error-output', '‚úÖ Word API can handle large document reading');
                    
                    // Test inserting analysis results
                    const summaryText = `\n\n[ILANA ANALYSIS SUMMARY]\nProtocol Size: ${finalSize.toLocaleString()} characters\nProcessing Time: ${processingTime?.toFixed(2) || 'N/A'} seconds\nRecommendations: Multiple optimization opportunities identified\n`;
                    body.insertText(summaryText, Word.InsertLocation?.end || 'End');
                    await context.sync();
                    
                    appendOutput('error-output', '‚úÖ Word API can insert analysis results for large protocols');
                });
                
            } catch (error) {
                appendOutput('error-output', `‚ö†Ô∏è Word API large document handling: ${error.message}`);
            }
            
            // Enterprise recommendations
            appendOutput('error-output', 'üè¢ ENTERPRISE RECOMMENDATIONS for 200K+ character protocols:');
            appendOutput('error-output', '   ‚Ä¢ Implement progressive document chunking (10-20KB chunks)');
            appendOutput('error-output', '   ‚Ä¢ Add real-time progress indicators for long-running analysis');
            appendOutput('error-output', '   ‚Ä¢ Use background processing with WebSocket status updates');
            appendOutput('error-output', '   ‚Ä¢ Implement smart caching for repeated large document analysis');
            appendOutput('error-output', '   ‚Ä¢ Add memory management and garbage collection optimization');
            appendOutput('error-output', '   ‚Ä¢ Consider server-side document preprocessing for very large protocols');
            appendOutput('error-output', '   ‚Ä¢ Implement retry logic for network timeouts on large uploads');
            appendOutput('error-output', '   ‚Ä¢ Add document size warnings and optimization suggestions for users');
        }

        // Performance Tests
        async function testPerformance() {
            updateOutput('performance-output', 'Running performance tests...');
            
            const startTime = performance.now();
            
            // Test multiple operations
            for (let i = 0; i < 5; i++) {
                await testDocumentAccess();
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            appendOutput('performance-output', `5 document access operations completed in ${duration.toFixed(2)}ms`);
            appendOutput('performance-output', `Average operation time: ${(duration / 5).toFixed(2)}ms`);
            
            updateStatus('performance-status', 'performance-status-text', 'Performance Tested', true);
        }

        async function testConcurrentOperations() {
            appendOutput('performance-output', 'Testing concurrent operations...');
            
            const startTime = performance.now();
            
            // Run multiple operations concurrently
            const operations = [
                testDocumentAccess(),
                testTextInsertion(),
                testAnalyzeDocument()
            ];
            
            await Promise.all(operations);
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            appendOutput('performance-output', `3 concurrent operations completed in ${duration.toFixed(2)}ms`);
        }

        // Initialize tests when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üß™ Ilana Word API Test Suite loaded');
            
            // Auto-start Office.js test
            setTimeout(() => {
                testOfficeInitialization();
            }, 1000);
        });
    </script>
</body>
</html>